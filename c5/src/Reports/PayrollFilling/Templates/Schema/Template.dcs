<?xml version="1.0" encoding="UTF-8"?>
<DataCompositionSchema xmlns="http://v8.1c.ru/8.1/data-composition-system/schema" xmlns:dcscom="http://v8.1c.ru/8.1/data-composition-system/common" xmlns:dcscor="http://v8.1c.ru/8.1/data-composition-system/core" xmlns:dcsset="http://v8.1c.ru/8.1/data-composition-system/settings" xmlns:v8="http://v8.1c.ru/8.1/data/core" xmlns:v8ui="http://v8.1c.ru/8.1/data/ui" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<dataSource>
		<name>DataSource1</name>
		<dataSourceType>Local</dataSourceType>
	</dataSource>
	<dataSet xsi:type="DataSetQuery">
		<name>Payroll</name>
		<field xsi:type="DataSetFieldField">
			<dataPath>Employee</dataPath>
			<field>Employee</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Employee</v8:content>
				</v8:item>
				<v8:item>
					<v8:lang>ro</v8:lang>
					<v8:content>Angajat</v8:content>
				</v8:item>
			</title>
			<role>
				<dcscom:dimension>true</dcscom:dimension>
			</role>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Department</dataPath>
			<field>Department</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Position</dataPath>
			<field>Position</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Schedule</dataPath>
			<field>Schedule</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Company</dataPath>
			<field>Company</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Company</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BaseHolidays</dataPath>
			<field>BaseHolidays</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base holidays</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Bonuses</dataPath>
			<field>Bonuses</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Bonuses</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BasePeriod</dataPath>
			<field>BasePeriod</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base period</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ScheduledDays</dataPath>
			<field>ScheduledDays</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Scheduled days</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Compensation</dataPath>
			<field>Compensation</field>
			<role>
				<dcscom:dimension>true</dcscom:dimension>
			</role>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ExchangeFactor</dataPath>
			<field>ExchangeFactor</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Exchange factor</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Expenses</dataPath>
			<field>Expenses</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>HourlyRate</dataPath>
			<field>HourlyRate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Hourly rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>AccountingResult</dataPath>
			<field>AccountingResult</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Account</dataPath>
			<field>Account</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Account</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Result</dataPath>
			<field>Result</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Result</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Edit</dataPath>
			<field>Edit</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>DateStart</dataPath>
			<field>DateStart</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Date start</v8:content>
				</v8:item>
			</title>
			<role>
				<dcscom:dimension>true</dcscom:dimension>
			</role>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>DateEnd</dataPath>
			<field>DateEnd</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Date end</v8:content>
				</v8:item>
			</title>
			<role>
				<dcscom:dimension>true</dcscom:dimension>
			</role>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Rate</dataPath>
			<field>Rate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Level</dataPath>
			<field>Level</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Level</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Currency</dataPath>
			<field>Currency</field>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ScheduledHours</dataPath>
			<field>ScheduledHours</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Scheduled hours</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Hours</dataPath>
			<field>Hours</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Hours</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ExchangeRate</dataPath>
			<field>ExchangeRate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Exchange rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Days</dataPath>
			<field>Days</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Days</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Reference</dataPath>
			<field>Reference</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Reference</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Priority</dataPath>
			<field>Priority</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Priority</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>DailyRate</dataPath>
			<field>DailyRate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Daily rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BaseAmount</dataPath>
			<field>BaseAmount</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base amount</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Individual</dataPath>
			<field>Individual</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Individual</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BaseDays</dataPath>
			<field>BaseDays</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base days</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>OnCompany</dataPath>
			<field>OnCompany</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>On company</v8:content>
				</v8:item>
			</title>
		</field>
		<dataSource>DataSource1</dataSource>
		<query>// Time
select dateadd ( &amp;DateStart, day, 11 * 11 * ( Rate1.Factor ) + 11 * ( Rate2.Factor ) + ( Rate3.Factor ) ) as Day
into Time
from (
	select 1 as Factor union all select 2 union all select 3 union all select 4 union all select 5 union all select 6
	union all select 7 union all select 8 union all select 9 union all select 10 union all select 11 union all select 0
	union all select -1 union all select -2 union all select -3 union all select -4 union all select -5 union all select -6 
	union all select -7 union all select -8 union all select -9 union all select -10 union all select -11
	) as Rate1,
	(
	select 1 as Factor union all select 2 union all select 3 union all select 4 union all select 5 union all select 6
	union all select 7 union all select 8 union all select 9 union all select 10 union all select 11 union all select 0
	union all select -1 union all select -2 union all select -3 union all select -4 union all select -5 union all select -6 
	union all select -7 union all select -8 union all select -9 union all select -10 union all select -11
	) as Rate2,
	(
	select 1 as Factor union all select 2 union all select 3 union all select 4 union all select 5 union all select 6
	union all select 7 union all select 8 union all select 9 union all select 10 union all select 11 union all select 0
	union all select -1 union all select -2 union all select -3 union all select -4 union all select -5 union all select -6 
	union all select -7 union all select -8 union all select -9 union all select -10 union all select -11
	) as Rate3
where 11 * 11 * ( Rate1.Factor ) + 11 * ( Rate2.Factor ) + ( Rate3.Factor ) &lt; 366 * 3
group by dateadd ( &amp;DateStart, day, 11 * 11 * ( Rate1.Factor ) + 11 * ( Rate2.Factor ) + ( Rate3.Factor ) )
index by Day
;
// Spans
select dateadd ( &amp;DateStart, month, 4 * 4 * ( Rate1.Factor - 1 ) + 4 * ( Rate2.Factor - 1 ) + ( Rate3.Factor - 1 ) ) as DateStart,
	endofperiod ( dateadd ( &amp;DateStart, month, 4 * 4 * ( Rate1.Factor - 1 ) + 4 * ( Rate2.Factor - 1 ) + ( Rate3.Factor - 1 ) ), month ) as DateEnd
into Spans
from (
	select 1 as Factor union all select 2 union all select 3 union all select 4
	union all select 0 union all select -1 union all select -2 union all select -3
	) as Rate1,
	(
	select 1 as Factor union all select 2 union all select 3 union all select 4
	) as Rate2,
	(
	select 1 as Factor union all select 2 union all select 3 union all select 4
	) as Rate3
where 4 * 4 * ( Rate1.Factor - 1 ) + 4 * ( Rate2.Factor - 1 ) + ( Rate3.Factor - 1 ) &lt; 12 * 3
;
// Calendar
select Time.Day as Day
into Calendar
from Time as Time
where Time.Day between &amp;DateStart and dateadd ( &amp;DateEnd, day, -1 )
and not &amp;TaxesOnly
union all
select beginofperiod ( &amp;DateEnd, day )
where not &amp;TaxesOnly
index by Day
;
// CalculatingPayroll
select distinct Compensations.Employee as Employee
into CalculatingPayroll
from Document.Payroll.Compensations as Compensations
where Compensations.Ref = &amp;CalculatingPayroll
index by Employee
;
// Employees
select Employees.Employee as Employee, &amp;DateStart as Period, Employees.Hired as Hired
into Employees
from InformationRegister.Employees.SliceLast ( &amp;DateStart,
	{Employee in ( select Employee from CalculatingPayroll where &amp;CalculatingPayroll &lt;&gt; value ( Document.Payroll.EmptyRef ) )}
	{Employee.* as Employee, Employee.Company.* as Company} ) as Employees
where Employees.Hired
and not &amp;TaxesOnly
union
select Employees.Employee, Employees.Period, Employees.Hired
from InformationRegister.Employees as Employees
where Employees.Period &gt; &amp;DateStart and Employees.Period &lt;= &amp;DateEnd
and not &amp;TaxesOnly
{where Employees.Employee.* as Employee, Employees.Employee.Company.* as Company,
Employees.Employee in ( select Employee from CalculatingPayroll where &amp;CalculatingPayroll &lt;&gt; value ( Document.Payroll.EmptyRef ) )}
index by Employee
;
// Employment
select Employees.Employee as Employee, Employees.Period as DateStart,
	isnull ( Terminated.Period, &amp;DateEnd ) as DateEnd
into Employment
from Employees as Employees
	//
	// Terminated
	//
	left join Employees as Terminated
	on Terminated.Employee = Employees.Employee
	and Terminated.Period &gt; Employees.Period
	and not Terminated.Hired
where Employees.Hired
and not &amp;TaxesOnly
;
// Personnel
select &amp;DateStart as Period, Personnel.Employee as Employee, Personnel.Department as Department,
	Personnel.Position as Position, Personnel.Schedule as Schedule, Personnel.Expenses as Expenses
into Personnel
from InformationRegister.Personnel.SliceLast ( &amp;DateStart, Employee in ( select distinct Employee from Employees ) ) as Personnel
{where Department.* as Department, Position.* as Position, Schedule.* as Schedule}
union
select Personnel.Period, Personnel.Employee, Personnel.Department, Personnel.Position, Personnel.Schedule, Personnel.Expenses
from InformationRegister.Personnel as Personnel
where Personnel.Period &gt; &amp;DateStart and Personnel.Period &lt;= &amp;DateEnd
and Personnel.Employee in ( select distinct Employee from Employees )
{where Department.* as Department, Position.* as Position, Schedule.* as Schedule}
;
// Changes
select Personnel.Employee as Employee, Personnel.Period as DateStart,
	min ( isnull ( dateadd ( Changes.Period, second, -1 ), Employment.DateEnd ) ) as DateEnd
into Changes
from Personnel as Personnel
	//
	// Employment
	//
	join Employment as Employment
	on Employment.Employee = Personnel.Employee
	and Personnel.Period between Employment.DateStart and Employment.DateEnd
	//
	// Changes
	//
	left join Personnel as Changes
	on Changes.Period &gt; Personnel.Period
	and Changes.Period &lt; Employment.DateEnd
	and Changes.Employee = Personnel.Employee
	and ( Personnel.Department &lt;&gt; Changes.Department
		or Personnel.Position &lt;&gt; Changes.Position
		or Personnel.Schedule &lt;&gt; Changes.Schedule
		or Personnel.Expenses &lt;&gt; Changes.Expenses )
group by Personnel.Employee, Personnel.Period
;
// Additions
select Rates.Employee as Employee, Rates.Compensation as Compensation, Rates.Currency as Currency,
	Rates.Rate as Rate, Rates.InHand as InHand
into Additions
from &amp;Additions as Rates
;
// Rates
select Rates.Employee as Employee, Rates.Compensation as Compensation, Rates.Period as Period,
	Rates.Actual as Actual, Rates.Currency as Currency, Rates.Rate as Rate, Rates.InHand as InHand
into Rates
from (
	select Rates.Employee as Employee, Rates.Compensation as Compensation, &amp;DateStart as Period,
		Rates.Actual as Actual, Rates.Currency as Currency, Rates.Rate as Rate, Rates.InHand as InHand
	from InformationRegister.EmployeeRates.SliceLast ( &amp;DateStart, Employee in ( select distinct Employee from Employees ) ) as Rates
	where Rates.Actual
	union
	select Rates.Employee, Rates.Compensation, Rates.Period, Rates.Actual, Rates.Currency, Rates.Rate, Rates.InHand
	from InformationRegister.EmployeeRates as Rates
	where Rates.Period &gt; &amp;DateStart and Rates.Period &lt;= &amp;DateEnd
	and Rates.Employee in ( select distinct Employee from Employees )
) as Rates
union all
select Additions.Employee, Additions.Compensation, &amp;DateStart, true, Additions.Currency, Additions.Rate,
	Additions.InHand
from Additions as Additions
;
// CompensationPeriods
select Rates.Employee as Employee, Rates.Compensation as Compensation, Rates.Rate as Rate, Rates.InHand as InHand,
	Rates.Currency as Currency, Rates.Period as DateStart, min ( isnull ( Changes.Period, Employment.DateEnd ) ) as DateEnd
into CompensationPeriods
from Rates as Rates
	//
	// Filter by Employment
	//
	join Employment as Employment
	on Employment.Employee = Rates.Employee
	and Rates.Period between Employment.DateStart and Employment.DateEnd
	//
	// Changes
	//
	left join Rates as Changes
	on Changes.Employee = Rates.Employee
	and Changes.Compensation = Rates.Compensation
	and Changes.Period &gt; Rates.Period
	and Changes.Period &lt; Employment.DateEnd
where Rates.Actual
group by Rates.Employee, Rates.Compensation, Rates.Rate, Rates.InHand, Rates.Currency, Rates.Period
index by Employee
;
// Compensations
select Compensations.Employee as Employee, Compensations.Compensation as Compensation,
	Compensations.Rate as Rate, Compensations.InHand as InHand, Compensations.Currency as Currency,
	AllPeriods.DateStart as DateStart, AllPeriods.DateEnd as DateEnd
into Compensations
from CompensationPeriods as Compensations
	//
	// AllPeriods
	//
	join (
		select Rates.Employee as Employee, Rates.Period as DateStart,
			isnull ( min ( dateadd ( Changes.Period, day, -1 ) ), min ( Employment.DateEnd ) ) as DateEnd
		from Rates as Rates
			//
			// Filter by Employment
			//
			join Employment as Employment
			on Employment.Employee = Rates.Employee
			and Rates.Period between Employment.DateStart and Employment.DateEnd
			//
			// Changes
			//
			left join Rates as Changes
			on Changes.Employee = Rates.Employee
			and Changes.Period &gt; Rates.Period
			and Changes.Period &lt; Employment.DateEnd
		group by Rates.Employee, Rates.Period
	) as AllPeriods
	on AllPeriods.Employee = Compensations.Employee
	and AllPeriods.DateStart &gt;= Compensations.DateStart
	and AllPeriods.DateEnd &lt;= Compensations.DateEnd
index by Employee
;
// ScheduledLocation
select Personnel.Employee as Employee, Personnel.Department as Department, Personnel.Position as Position,
	Personnel.Schedule as Schedule, Personnel.Expenses as Expenses,
	Changes.DateStart as DateStart, Changes.DateEnd as DateEnd
into ScheduledLocation
from Personnel as Personnel
	//
	// Changed
	//
	join Changes as Changes
	on Changes.Employee = Personnel.Employee
	and Personnel.Period between Changes.DateStart and Changes.DateEnd
	//
	// Filter by Employment
	//
	join Employment as Employment
	on Employment.Employee = Changes.Employee
	and Changes.DateStart between Employment.DateStart and Employment.DateEnd
	and Changes.DateEnd between Employment.DateStart and Employment.DateEnd
;
// LocationByDays
select Calendar.Day as Day, Location.Employee as Employee, Location.Department as Department,
	Location.Position as Position, Location.Schedule as Schedule, Location.Expenses as Expenses,
	case
		when Vacations.Employee is not null then true
		when SickLeaves.Employee is not null then true
		when Absences.Minutes = Schedules.Minutes then true
		else false
	end as Absence
into LocationByDays
from Calendar as Calendar
	//
	// Location
	//
	join ScheduledLocation as Location
	on Calendar.Day between Location.DateStart and Location.DateEnd
	//
	// Schedules
	//
	left join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Location.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day = Calendar.Day
	and Schedules.Minutes &gt; 0
	//
	// Vacations
	//
	left join Document.Vacation.Employees as Vacations
	on Vacations.Employee = Location.Employee
	and Calendar.Day between Vacations.DateStart and Vacations.DateEnd
	and Vacations.Ref.Posted
	//
	// SickLeaves
	//
	left join Document.SickLeave as SickLeaves
	on SickLeaves.Employee = Location.Employee
	and Calendar.Day between SickLeaves.DateStart and SickLeaves.DateEnd
	and SickLeaves.Posted
	//
	// Absences
	//
	left join InformationRegister.Hours as Absences
	on Absences.Employee = Location.Employee
	and Absences.Day = Calendar.Day
	and Absences.Time in (
		value ( Enum.Time.Absence ),
		value ( Enum.Time.Vacation ),
		value ( Enum.Time.ExtendedVacation ),
		value ( Enum.Time.Sickness )
	)
;
// LocationGaps
select Location.Employee as Employee, Location.Department as Department,
	Location.Position as Position, Location.Schedule as Schedule, Location.Expenses as Expenses,
	Location.Day as DateStart, min  ( NextPeriods.Day ) as DateEnd
into LocationGaps
from LocationByDays as Location
	//
	// NextPeriods
	//
	left join LocationByDays as NextPeriods
	on NextPeriods.Day &gt; Location.Day
	and NextPeriods.Employee = Location.Employee
	and NextPeriods.Department = Location.Department
	and NextPeriods.Position = Location.Position
	and NextPeriods.Schedule = Location.Schedule
	and NextPeriods.Expenses = Location.Expenses
	and not NextPeriods.Absence
where not Location.Absence
group by Location.Day, Location.Employee, Location.Department, Location.Position, Location.Schedule, Location.Expenses
having datediff ( Location.Day, min ( NextPeriods.Day ), day ) &gt; 1
;
// Location
select Bottom.Day as DateStart, min ( endofperiod ( isnull ( Gaps.DateStart, Bottom.LastWorkDay ), day ) ) as DateEnd,
	Bottom.Employee as Employee, Bottom.Department as Department, Bottom.Position as Position,
	Bottom.Schedule as Schedule, Bottom.Expenses as Expenses
into Location
from (
	select min ( Location.Day ) as Day, max ( Location.Day ) as LastWorkDay,
		Location.Employee as Employee, Location.Department as Department,
		Location.Position as Position, Location.Schedule as Schedule, Location.Expenses as Expenses
	from LocationByDays as Location
	where not Location.Absence
	group by Location.Employee, Location.Department, Location.Position, Location.Schedule, Location.Expenses
	) as Bottom
	//
	// Gaps
	//
	left join LocationGaps as Gaps
	on Gaps.DateStart &gt;= Bottom.Day
	and Gaps.Employee = Bottom.Employee
	and Gaps.Department = Bottom.Department
	and Gaps.Position = Bottom.Position
	and Gaps.Schedule = Bottom.Schedule
	and Gaps.Expenses = Bottom.Expenses
group by Bottom.Day, Bottom.Employee, Bottom.Department, Bottom.Position, Bottom.Schedule, Bottom.Expenses
union
select Up.Day, max ( Location.Day ), Up.Employee, Up.Department, Up.Position, Up.Schedule, Up.Expenses
from (
	select max ( Gaps.DateEnd ) as Day, Gaps.Employee as Employee, Gaps.Department as Department,
		Gaps.Position as Position, Gaps.Schedule as Schedule, Gaps.Expenses as Expenses
	from LocationGaps as Gaps
	group by Gaps.Employee, Gaps.Department, Gaps.Position, Gaps.Schedule, Gaps.Expenses
	) as Up
	//
	// Location
	//
	join LocationByDays as Location
	on Location.Day &gt; Up.Day
	and Location.Employee = Up.Employee
	and Location.Department = Up.Department
	and Location.Position = Up.Position
	and Location.Schedule = Up.Schedule
	and Location.Expenses = Up.Expenses
	and not Location.Absence
group by Up.Day, Up.Employee, Up.Department, Up.Position, Up.Schedule, Up.Expenses
union
select Previous.DateEnd, min ( Next.DateStart ),
	Previous.Employee, Previous.Department, Previous.Position, Previous.Schedule, Previous.Expenses
from LocationGaps as Previous
	//
	// Next
	//
	join LocationGaps as Next
	on Next.DateStart &gt; Previous.DateEnd
	and Next.Employee = Previous.Employee
	and Next.Department = Previous.Department
	and Next.Position = Previous.Position
	and Next.Schedule = Previous.Schedule
	and Next.Expenses = Previous.Expenses
group by Previous.DateEnd, Previous.Employee, Previous.Department, Previous.Position, Previous.Schedule, Previous.Expenses
index by Employee
;
// LastLocation
select LatestLocation.DateEnd as DateEnd, Location.Employee as Employee, Location.Department as Department,
	Location.Position as Position, Location.Schedule as Schedule, Location.Expenses as Expenses
into LastLocation
from Location as Location
	//
	// LatestLocation
	//
	join (
		select max ( Location.DateEnd ) as DateEnd, Location.Employee as Employee
	    from Location as Location
	    group by Location.Employee
	) as LatestLocation
	on LatestLocation.Employee = Location.Employee
	and LatestLocation.DateEnd = Location.DateEnd
;
// Intervals
select distinct Intervals.Employee as Employee, Intervals.Schedule as Schedule,
	Intervals.DateStart as DateStart, Intervals.DateEnd as DateEnd, Intervals.Department.Division as Division
into Intervals
from Location as Intervals
index by Employee, Schedule
;
// ScheduledIntervals
select distinct Intervals.Employee as Employee, Intervals.Schedule as Schedule,
	Intervals.DateStart as DateStart, Intervals.DateEnd as DateEnd, Intervals.Department.Division as Division
into ScheduledIntervals
from ScheduledLocation as Intervals
index by Employee, Schedule
;
// HolidaysRawData
select HolidaysList.Reference as Reference, HolidaysList.Day as Day, dateadd ( HolidaysList.Day, day, -1 ) as Preholiday,
	HolidaysList.Division as Division, Schedules.Schedule as Schedule
into HolidaysRawData
from InformationRegister.Holidays as HolidaysList
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day = HolidaysList.Day
	and Schedules.Schedule.Holidays = HolidaysList.Reference
	and Schedules.Minutes &gt; 0
where HolidaysList.Day between &amp;YearStart and &amp;DateEnd
;
// All holidays
select Divisions.Ref as Division, Holidays.Reference as Reference, Holidays.Day as Day, Holidays.Preholiday as Preholiday,
	Holidays.Schedule as Schedule
into AllHolidays
from (
	select value ( Catalog.Divisions.EmptyRef ) as Ref
	union all
	select Divisions.Ref
	from Catalog.Divisions as Divisions
	where not Divisions.DeletionMark
) as Divisions
	//
	// CommonHolidays
	//
	join HolidaysRawData as Holidays
	on Holidays.Division = value ( Catalog.Divisions.EmptyRef )
union all
select LocalHolidays.Division, LocalHolidays.Reference, LocalHolidays.Day, LocalHolidays.Preholiday, LocalHolidays.Schedule
from HolidaysRawData as LocalHolidays
where LocalHolidays.Division &lt;&gt; value ( Catalog.Divisions.EmptyRef )
;
// Only holidays falling on working days
select Holidays.Day as Day, Holidays.Preholiday as Preholiday, Holidays.Division as Division, Holidays.Schedule as Schedule
into Holidays
from AllHolidays as Holidays
where Holidays.Day between &amp;DateStart and &amp;DateEnd
;
// Schedules
select Schedules.Schedule as Schedule, Intervals.DateStart as DateStart, Intervals.DateEnd as DateEnd, Intervals.Division as Division,
	sum ( Schedules.Minutes ) / 60 as Hours, sum ( case Schedules.Minutes when 0 then 0 else 1 end ) as Days,
	sum ( Schedules.MinutesEvening ) / 60 as HoursEvening, sum ( case Schedules.MinutesEvening when 0 then 0 else 1 end ) as DaysEvening,
	sum ( Schedules.MinutesNight ) / 60 as HoursNight, sum ( case Schedules.MinutesNight when 0 then 0 else 1 end ) as DaysNight,
	sum ( case when Holidays.Day is not null then Schedules.Minutes else 0 end / 60 )
	+ sum ( case when Preholidays.Preholiday is not null then 1 else 0 end ) as HolidaysHours,
	sum ( case when Holidays.Day is not null then 1 else 0 end ) as HolidaysDays
into Schedules
from InformationRegister.Schedules as Schedules
	//
	// Intervals
	//
	join (
		select Intervals.Schedule as Schedule, Intervals.DateStart as DateStart,
			Intervals.DateEnd as DateEnd, Intervals.Division as Division
		from Intervals as Intervals
		union
		select Intervals.Schedule, &amp;StartMonth, &amp;EndMonth, Intervals.Division
		from Intervals as Intervals
		) as Intervals
	on Intervals.Schedule = Schedules.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day between Intervals.DateStart and Intervals.DateEnd
	//
	// Holidays
	//
	left join Holidays as Holidays
	on Holidays.Schedule = Schedules.Schedule
	and Holidays.Day = Schedules.Day
	and Holidays.Division = Intervals.Division
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Minutes &gt; 0
	//
	// Preholidays
	//
	left join Holidays as Preholidays
	on Preholidays.Schedule = Schedules.Schedule
	and Preholidays.Preholiday = Schedules.Day
	and Preholidays.Division = Intervals.Division
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Minutes &gt; 0
group by Schedules.Schedule, Intervals.DateStart, Intervals.DateEnd, Intervals.Division
;
// Average
select Schedules.Schedule as Schedule, Divisions.Division as Division,
	cast (
		sum ( case when Holidays.Day is not null then 0 else Schedules.Minutes end )
		/ 60 / 12 as Number ( 4 )
	) as Hours
into Average
from InformationRegister.Schedules as Schedules
	//
	// Divisions
	//
	join (
		select distinct Divisions.Schedule as Schedule, Divisions.Division as Division
		from Intervals as Divisions
	) as Divisions
	on Divisions.Schedule = Schedules.Schedule
	//
	// Holidays
	//
	left join AllHolidays as Holidays
	on Holidays.Reference = Schedules.Schedule.Holidays
	and Holidays.Day = Schedules.Day
	and Holidays.Division = Divisions.Division
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Minutes &gt; 0
where Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
and Schedules.Minutes &gt; 0
group by Schedules.Schedule, Divisions.Division
;
// Deviations
select Hours.Employee as Employee, Hours.Time as Time, Hours.Day as Day, sum ( Hours.Minutes ) as Minutes
into Deviations
from InformationRegister.Hours as Hours
	//
	// Filter by Employment
	//
	join Employment as Employment
	on Employment.Employee = Hours.Employee
	and Hours.Day between Employment.DateStart and Employment.DateEnd
where Hours.Time in (
	value ( Enum.Time.Banked ),
	value ( Enum.Time.BankedUse ),
	value ( Enum.Time.Overtime ),
	value ( Enum.Time.Absence ),
	value ( Enum.Time.Holiday ),
	value ( Enum.Time.DayOff ) )
group by Hours.Employee, Hours.Time, Hours.Day
index by Employee, Day
;
// OtherCompensations
select top 1 value ( Enum.Time.Overtime ) as Time, Compensations.Ref as Compensation
into OtherCompensations
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.Overtime )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.DayOff ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.DayOff )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.Holiday ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.HolidayHours )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.Absence ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.Absence )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.Banked ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.Banked )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.BankedUse ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.BankedUse )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.Vacation ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.Vacation )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.ExtendedVacation ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.ExtendedVacation )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
union all
select top 1 value ( Enum.Time.Sickness ), Compensations.Ref
from ChartOfCalculationTypes.Compensations as Compensations
where Compensations.Method = value ( Enum.Calculations.SickDays )
and not Compensations.DeletionMark
and not &amp;TaxesOnly
;
// NoTimesheets
select Employees.Employee as Employee
into NoTimesheets
from Employees as Employees
	//
	// Timesheet
	//
	left join Document.Timesheet as Timesheet
	on Timesheet.DateStart between &amp;DateStart and &amp;DateEnd
	and Timesheet.Employee = Employees.Employee
	and not Timesheet.DeletionMark
	//
	// Allowed only
	//
	join Constants as Constants
	on not Constants.Timesheets
where Timesheet.Ref is null
union 
select Employees.Employee
from Employees as Employees
	//
	// Timesheet
	//
	left join Document.Timesheet as Timesheet
	on Timesheet.DateEnd between &amp;DateStart and &amp;DateEnd
	and Timesheet.Employee = Employees.Employee
	and not Timesheet.DeletionMark
	//
	// Allowed only
	//
	join Constants as Constants
	on not Constants.Timesheets
where Timesheet.Ref is null
;
// Vacations
select Vacations.Ref as Ref, Vacations.Employee as Employee, Time.Day as Day, Vacations.Compensation as Compensation,
	Schedules.Minutes as Minutes, Schedules.Minutes as ScheduledMinutes, HolidaysList.Day as Holiday,
	Spans.DateStart as SpanStart, Spans.DateEnd as SpanEnd
into Vacations
from Document.Vacation.Employees as Vacations
	//
	// Time
	//
	join Time as Time
	on Time.Day between Vacations.DateStart and Vacations.DateEnd
	//
	// ScheduledIntervals
	//
	join ScheduledIntervals as Intervals
	on Intervals.Employee = Vacations.Employee
	and Time.Day between Intervals.DateStart and Intervals.DateEnd
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Intervals.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day = Time.Day
	//
	// Holidays
	//
	left join AllHolidays as HolidaysList
	on HolidaysList.Reference = Schedules.Schedule.Holidays
	and HolidaysList.Division = Intervals.Division
	and HolidaysList.Day = Schedules.Day
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Minutes &gt; 0
	//
	// Spans
	//
	join Spans as Spans
	on Time.Day between Spans.DateStart and Spans.DateEnd
where Vacations.Ref.Posted
union all
select Hours.Recorder, Hours.Employee, Hours.Day, OtherCompensations.Compensation, Hours.Minutes, Schedules.Minutes,
	null, Spans.DateStart, Spans.DateEnd
from InformationRegister.Hours as Hours
	//
	// Exclude already created Vacation documents
	//
	left join Document.Vacation.Employees as Vacations
	on Vacations.Employee = Hours.Employee
	and Hours.Day between Vacations.DateStart and Vacations.DateEnd
	and Vacations.Ref.Posted
	//
	// OtherCompensations
	//
	left join OtherCompensations as OtherCompensations
	on OtherCompensations.Time = Hours.Time
	//
	// ScheduledIntervals
	//
	join ScheduledIntervals as Intervals
	on Intervals.Employee = Hours.Employee
	and Hours.Day between Intervals.DateStart and Intervals.DateEnd
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Intervals.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day = Hours.Day
	//
	// Spans
	//
	join Spans as Spans
	on Hours.Day between Spans.DateStart and Spans.DateEnd
where Hours.Day between &amp;DateStart and &amp;DateEnd
and Hours.Time in ( value ( Enum.Time.Vacation ), value ( Enum.Time.ExtendedVacation ) )
and Vacations.Ref is null
and not &amp;TaxesOnly
index by Employee, Day
;
// VacationsToCalculate
select Vacations.Ref as Ref, Vacations.Employee as Employee, Vacations.Compensation as Compensation,
	Vacations.DateStart as DateStart, Vacations.DateEnd as DateEnd, Schedules.Schedule as Schedule, 
	1 + datediff ( Vacations.DateStart, Vacations.DateEnd, day )
	- sum ( case when HolidaysList.Day is null then 0 else 1 end ) as Days
into VacationsToCalculate
from Document.Vacation.Employees as Vacations
	//
	// Location
	//
	join LocationByDays as Location
	on Location.Employee = Vacations.Employee
	and Location.Day = Vacations.DateStart
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Location.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day between Vacations.DateStart and Vacations.DateEnd
	//
	// Holidays
	//
	left join AllHolidays as HolidaysList
	on HolidaysList.Reference = Schedules.Schedule.Holidays
	and HolidaysList.Division = Location.Department.Division
	and HolidaysList.Day = Schedules.Day
	and Schedules.Minutes &gt; 0
where Vacations.DateStart between &amp;DateStart and &amp;DateEnd
and Vacations.Employee in ( select distinct Employee from Employment )
and Vacations.Compensation.Method = value ( Enum.Calculations.Vacation )
and Vacations.Ref.Posted
group by Vacations.Ref, Vacations.Employee, Vacations.Compensation, Vacations.DateStart, Vacations.DateEnd, Schedules.Schedule
;
// PreviousCompensationsForVacations
select Vacations.Ref as Ref, Compensations.Employee as Employee, Compensations.Department.Division as Division,
	Compensations.Compensation as Compensation, Compensations.Schedule as Schedule, Compensations.DateStart as DateStart, 
	Compensations.DateEnd as DateEnd, Compensations.AccountingResult as Amount, 
	Compensations.Compensation.Method as Method, Compensations.Days as Days, 
	Compensations.ScheduledDays as ScheduledDays, Compensations.Schedule.AverageDays as AverageDays
into PreviousCompensationsForVacations
from VacationsToCalculate as Vacations 
	//
	// Compensations
	//
	join Document.Payroll.Compensations as Compensations
	on Compensations.Ref.Posted
	and Compensations.Employee = Vacations.Employee
	and Compensations.DateStart &gt;= dateadd ( beginofperiod ( Vacations.DateStart, month ), month, -3 )
	and Compensations.DateEnd &lt;= beginofperiod ( Vacations.DateStart, month )
index by Employee
;
// PreviousSchedulesForVacations
select Vacations.Ref as Ref, Vacations.Employee as Employee, 
	Schedules.Schedule as Schedule, beginofperiod ( Schedules.Day, month ) as Period,
	count ( Schedules.Minutes ) as Days
into PreviousSchedulesForVacations
from VacationsToCalculate as Vacations
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Vacations.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day &gt;= dateadd ( beginofperiod ( Vacations.DateStart, month ), month, -3 )
	and Schedules.Day &lt; beginofperiod ( Vacations.DateStart, month )
	and Schedules.Minutes &gt; 0
group by Vacations.Ref, Vacations.Employee, Schedules.Schedule, beginofperiod ( Schedules.Day, month )
;
// VacationRates
select Compensations.Ref as Ref, Compensations.Employee as Employee, Compensations.Amount as Amount, Compensations.Days as Days,
	Compensations.Bonuses as Bonuses, datediff ( Compensations.DateStart, Compensations.DateEnd, day ) + 1 as Period, Holidays.Days as Holidays,
	Compensations.AnnualBonuses as AnnualBonuses, Compensations.QuarterlyBonuses as QuarterlyBonuses,
	Schedules.Days - isnull ( Holidays.Days, 0 ) as ScheduledDays,
	case when Compensations.Days = 0 then 0
		else ( Compensations.Amount / Compensations.Days + Compensations.Bonuses ) 
			* Schedules.Days / ( datediff ( Compensations.DateStart, Compensations.DateEnd, day ) - Holidays.Days )
	end as Rate
into VacationRates
from (
	select Vacations.Ref as Ref, Compensations.Employee as Employee, 
		Compensations.Schedule as Schedule,
		sum (
			case when Compensations.Days &gt; 0
					and Compensations.Method in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent )
					) then Compensations.Amount / Compensations.Days
				when Compensations.Method = value ( Enum.Calculations.Annual )
					then Compensations.Amount / 12 / case when Compensations.AverageDays = 0 then 1 else Compensations.AverageDays end
				when Compensations.Method = value ( Enum.Calculations.Quarterly )
					then Compensations.Amount / 3 / case when Compensations.AverageDays = 0 then 1 else Compensations.AverageDays end
				else 0
			end
		) as Bonuses,
		sum (
			case when Compensations.Method = value ( Enum.Calculations.Annual )
				then Compensations.Amount
				else 0
			end
		) as AnnualBonuses,
		sum (
			case when Compensations.Method = value ( Enum.Calculations.Quarterly )
				then Compensations.Amount
				else 0
			end
		) as QuarterlyBonuses,
		sum (
			case when Compensations.Method not in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent ),
						value ( Enum.Calculations.Annual ),
						value ( Enum.Calculations.Quarterly )
					) then Compensations.Amount
				else 0
			end
		) as Amount,
		sum (
			case when Compensations.Method in (
						value ( Enum.Calculations.MonthlyRate ),
						value ( Enum.Calculations.HourlyRate )
					) then Compensations.Days
				when Compensations.Method in (
						value ( Enum.Calculations.Vacation ),
						value ( Enum.Calculations.SickDays ),
						value ( Enum.Calculations.SickDaysChild ),
						value ( Enum.Calculations.SickOnlySocial ),
						value ( Enum.Calculations.SickProduction )
					) then Compensations.ScheduledDays
				else 0
			end
		) as Days,
		min ( beginofperiod ( Compensations.DateEnd, month ) ) as DateStart,
		max ( endofperiod ( Compensations.DateEnd, month ) ) as DateEnd
	from PreviousCompensationsForVacations as Compensations
		//
		// BaseCompensations
		//
		join ChartOfCalculationTypes.Compensations.BaseCalculationTypes as BaseCompensations
		on BaseCompensations.CalculationType = Compensations.Compensation
		//
		// Vacations
		//
		join VacationsToCalculate as Vacations
		on Vacations.Employee = Compensations.Employee
		and Vacations.Compensation = BaseCompensations.Ref
	group by Vacations.Ref, Compensations.Employee, Compensations.Schedule
	) as Compensations
	//
	// Holidays for base period
	//
	left join (
		select Compensations.Employee as Employee,
			sum ( case when HolidaysList.Day is null then 0 else 1 end ) as Days
		from PreviousCompensationsForVacations as Compensations
			//
			// Schedules
			//
			join InformationRegister.Schedules as Schedules
			on Schedules.Schedule = Compensations.Schedule
			and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
			and Schedules.Day between Compensations.DateStart and Compensations.DateEnd
			//
			// Holidays
			//
			left join AllHolidays as HolidaysList
			on HolidaysList.Reference = Schedules.Schedule.Holidays
			and HolidaysList.Division = Compensations.Division
			and HolidaysList.Day = Schedules.Day
			and Schedules.Minutes &gt; 0
		where Compensations.Compensation.Method in ( value ( Enum.Calculations.MonthlyRate ), value ( Enum.Calculations.HourlyRate ) )
		group by Compensations.Employee
	) as Holidays
	on Holidays.Employee = Compensations.Employee
	//
	// Schedules
	//
	join (
		select Schedules.Ref as Ref, Schedules.Employee as Employee, 
			Schedules.Schedule as Schedule, sum ( Schedules.Days ) as Days
		from PreviousSchedulesForVacations as Schedules
		group by Schedules.Ref, Schedules.Employee, Schedules.Schedule
	) as Schedules
	on Schedules.Ref = Compensations.Ref
	and Schedules.Employee = Compensations.Employee
	and Schedules.Schedule = Compensations.Schedule
index by Employee
;
// Illness
select SickLeaves.Ref as Ref, SickLeaves.Employee as Employee,
	SickLeaves.DateStart as DateStart, SickLeaves.DateEnd as DateEnd,
	SickLeaves.Compensation as Compensation, not SickLeaves.Extension as First,
	Extended.Ref is null as Last
into Illness
from Document.SickLeave as SickLeaves
	//
	// Extended
	//
	left join Document.SickLeave as Extended
	on Extended.Base = SickLeaves.Ref
	and Extended.Posted
where SickLeaves.Posted
and SickLeaves.Employee in ( select distinct Employee from Personnel )
;
// Extended
select ExtendedStart.Ref as Ref, ExtendedStart.Employee as Employee,
	ExtendedStart.Compensation as Compensation, 
	ExtendedStart.DateStart as DateStart, min ( ExtendedEnd.DateEnd ) as DateEnd
into Extended
from Illness as ExtendedStart
	//
	// ExtendedEnd
	//
	left join Illness as ExtendedEnd
	on ExtendedEnd.Employee = ExtendedStart.Employee
	and ExtendedEnd.DateStart &gt; ExtendedStart.DateEnd
	and not ExtendedEnd.First
	and ExtendedEnd.Last
where ExtendedStart.First
and not ExtendedStart.Last  
group by ExtendedStart.Ref, ExtendedStart.Employee, ExtendedStart.DateStart, ExtendedStart.Compensation
;
// SickLeavesAll
select Regular.Ref as Ref, Regular.Employee as Employee,
	Regular.Compensation as Compensation,
	Regular.DateStart as DateStart, Regular.DateEnd as DateEnd,
	datediff ( Regular.DateStart, Regular.DateEnd, day ) + 1 as Days
into SickLeavesAll
from Illness as Regular
where Regular.DateEnd between &amp;DateStart and &amp;DateEnd
and Regular.First
and Regular.Last
union all
select Extended.Ref, Extended.Employee, Extended.Compensation,
	Extended.DateStart, Extended.DateEnd,
	datediff ( Extended.DateStart, Extended.DateEnd, day ) + 1
from Extended as Extended
where Extended.DateEnd between &amp;DateStart and &amp;DateEnd 
;
// Restrictions
select SickLeaves.Ref as Ref, cast ( isnull ( MaxDaysAtOnce.Value, 0 ) as number ( 10, 0 ) ) as MaxDaysAtOnce,
	cast ( isnull ( MaxDaysPerYear.Value, 0 ) as number ( 10, 0 ) ) as MaxDaysPerYear	 
into Restrictions
from (
	select SickLeaves.Ref as Ref, max ( MaxDaysAtOnce.Period ) as AtOncePeriod, 
		max ( MaxDaysPerYear.Period ) as PerYearPeriod 
	from SickLeavesAll as SickLeaves
		//
		// MaxDaysAtOnce
		//
		left join InformationRegister.Settings as MaxDaysAtOnce
		on MaxDaysAtOnce.Period &lt; SickLeaves.DateEnd
		and MaxDaysAtOnce.Parameter = value ( ChartOfCharacteristicTypes.Settings.MaxSickLeavesByCompanyAtOnce )  
		//
		// MaxDaysPerYear
		//
		left join InformationRegister.Settings as MaxDaysPerYear
		on MaxDaysPerYear.Period &lt; SickLeaves.DateEnd
		and MaxDaysPerYear.Parameter = value ( ChartOfCharacteristicTypes.Settings.MaxSickLeavesByCompanyPerYear )
	group by SickLeaves.Ref
	) as SickLeaves
	//
	// MaxDaysAtOnce
	//
	left join InformationRegister.Settings as MaxDaysAtOnce
	on MaxDaysAtOnce.Period = SickLeaves.AtOncePeriod 
	and MaxDaysAtOnce.Parameter = value ( ChartOfCharacteristicTypes.Settings.MaxSickLeavesByCompanyAtOnce )
	//
	// MaxDaysPerYear
	//
	left join InformationRegister.Settings as MaxDaysPerYear
	on MaxDaysPerYear.Period = SickLeaves.PerYearPeriod
	and MaxDaysPerYear.Parameter = value ( ChartOfCharacteristicTypes.Settings.MaxSickLeavesByCompanyPerYear ) 
;
// PossibleByCompany
select SickLeaves.Ref as Ref, SickLeaves.Employee as Employee, 
	SickLeaves.DateStart as DateStart, SickLeaves.DateEnd as DateEnd, 
	case when SickLeaves.Days &gt; Restrictions.MaxDaysAtOnce 
		then Restrictions.MaxDaysAtOnce 
		else SickLeaves.Days
	end as Days
into PossibleByCompany
from SickLeavesAll as SickLeaves
	//
	// Restrictions
	//
	left join Restrictions as Restrictions
	on Restrictions.Ref = SickLeaves.Ref
where SickLeaves.Compensation.Method in (
	value ( Enum.Calculations.SickDays ),
	value ( Enum.Calculations.SickProduction )
)
;
// UsedByCompanyPerMonth
select SickLeaves.Ref as Ref, sum ( isnull ( Previous.Days, 0 ) ) as Days  
into UsedByCompanyPerMonth
from PossibleByCompany as SickLeaves
	//
	// Previous
	//
	left join PossibleByCompany as Previous
	on Previous.DateEnd &lt; SickLeaves.DateStart
	and Previous.Employee = SickLeaves.Employee
group by SickLeaves.Ref
;
// UsedByCompanyPerYear
select SickLeaves.Ref as Ref, sum ( isnull ( Previous.Days, 0 ) ) as Days
into UsedByCompanyPerYear
from SickLeavesAll as SickLeaves
	//
	// Previous
	//
	left join Document.Payroll.Compensations as Previous
	on Previous.Employee = SickLeaves.Employee
	and Previous.Compensation.Method in ( value ( Enum.Calculations.SickDays ), value ( Enum.Calculations.SickProduction ) ) 
	and Previous.DateEnd between beginofperiod ( SickLeaves.DateEnd, year ) and SickLeaves.DateStart
	and Previous.Ref.Posted
group by SickLeaves.Ref
;
// UsedByCompany
select SickLeaves.Ref as Ref, sum ( SickLeaves.Days ) as Days
into UsedByCompany
from (
	select UsedByCompanyPerMonth.Ref as Ref, UsedByCompanyPerMonth.Days as Days
	from UsedByCompanyPerMonth as UsedByCompanyPerMonth
	union all
	select UsedByCompanyPerYear.Ref as Ref, UsedByCompanyPerYear.Days as Days
	from UsedByCompanyPerYear as UsedByCompanyPerYear	
	) as SickLeaves
group by SickLeaves.Ref
;
// SickLeaves
select SickLeaves.Ref as Ref, SickLeaves.Employee as Employee,
	SickLeaves.DateStart as DateStart, SickLeaves.DateEnd as DateEnd,
	SickLeaves.Compensation as Compensation, Time.Day as Day, Schedules.Minutes as Minutes, 
	Schedules.Minutes as ScheduledMinutes, Spans.DateStart as SpanStart, Spans.DateEnd as SpanEnd,
	case
		when SickLeaves.DaysByCompany is null then false
		else 1 + datediff ( SickLeaves.DateStart, Time.Day, day ) &lt;= SickLeaves.DaysByCompany
	end as OnCompany
into SickLeaves
from (
	select SickLeaves.Ref as Ref, SickLeaves.Employee as Employee,
		SickLeaves.Compensation as Compensation, SickLeaves.DateStart as DateStart,
		SickLeaves.DateEnd as DateEnd, SickLeaves.Days as Days,
		case
			when PossibleByCompany.Ref is null then
				null
			when ( Restrictions.MaxDaysPerYear - UsedByCompany.Days ) &lt;= 0 then
				0
			when ( Restrictions.MaxDaysPerYear - UsedByCompany.Days ) &lt;= PossibleByCompany.Days then
				( Restrictions.MaxDaysPerYear - UsedByCompany.Days )
			else
				PossibleByCompany.Days
		end as DaysByCompany
	from SickLeavesAll as SickLeaves
		//
		// Restrictions
		//
		left join Restrictions as Restrictions
		on Restrictions.Ref = SickLeaves.Ref
		//
		// UsedByCompany
		//
		left join UsedByCompany as UsedByCompany
		on UsedByCompany.Ref = SickLeaves.Ref
		//
		// PossibleByCompany
		//
		left join PossibleByCompany as PossibleByCompany
		on PossibleByCompany.Ref = SickLeaves.Ref
	) as SickLeaves
	//
	// Time
	//
	join Time as Time
	on Time.Day between SickLeaves.DateStart and SickLeaves.DateEnd
	//
	// ScheduledIntervals
	//
	join ScheduledIntervals as Intervals
	on Intervals.Employee = SickLeaves.Employee
	and Time.Day between Intervals.DateStart and Intervals.DateEnd
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Intervals.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day = Time.Day
	//
	// Spans
	//
	join Spans as Spans
	on Time.Day between Spans.DateStart and Spans.DateEnd
index by Employee, Day
;
// PreviousCompensationsForSickLeaves
select SickLeaves.Ref as Ref, Compensations.Employee as Employee, Compensations.Compensation as Compensation,
	Compensations.Department.Division as Division, Compensations.Schedule as Schedule,
	Compensations.DateStart as DateStart, Compensations.DateEnd as DateEnd, Compensations.AccountingResult as Amount, 
	Compensations.Compensation.Method as Method, Compensations.Days as Days, 
	Compensations.ScheduledDays as ScheduledDays, Compensations.Schedule.AverageDays as AverageDays
into PreviousCompensationsForSickLeaves
from SickLeavesAll as SickLeaves
	//
	// Compensations
	//
	join Document.Payroll.Compensations as Compensations
	on Compensations.Ref.Posted
	and Compensations.Employee = SickLeaves.Employee
	and Compensations.DateStart &gt;= dateadd ( beginofperiod ( SickLeaves.DateStart, month ), month, -3 )
	and Compensations.DateEnd &lt; beginofperiod ( SickLeaves.DateStart, month )
index by Ref, Employee
;
// PreviousSchedulesForSickLeaves
select SickLeaves.Ref as Ref, SickLeaves.Employee as Employee,
	Schedules.Schedule as Schedule, beginofperiod ( Schedules.Day, month ) as Period,
	count ( Schedules.Minutes ) as Days
into PreviousSchedulesForSickLeaves
from SickLeavesAll as SickLeaves
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day &gt;= dateadd ( beginofperiod ( SickLeaves.DateStart, month ), month, -3 )
	and Schedules.Day &lt; beginofperiod ( SickLeaves.DateStart, month )
	and Schedules.Minutes &gt; 0
group by SickLeaves.Ref, SickLeaves.Employee, Schedules.Schedule, beginofperiod ( Schedules.Day, month )
;
// SickLeavesRates
select Compensations.Ref as Ref, Compensations.Employee as Employee,
	Compensations.Amount as Amount, Compensations.Days as Days, Compensations.Bonuses as Bonuses, 
	datediff ( Compensations.DateStart, Compensations.DateEnd, day ) + 1 as Period, Holidays.Days as Holidays,
	Compensations.AnnualBonuses as AnnualBonuses, Compensations.QuarterlyBonuses as QuarterlyBonuses,
	Schedules.Days - isnull ( Holidays.Days, 0 ) as ScheduledDays,
	case when Compensations.Days = 0 then 0
		else ( Compensations.Amount / Compensations.Days + Compensations.Bonuses ) 
			* Schedules.Days / ( datediff ( Compensations.DateStart, Compensations.DateEnd, day ) + 1 - Holidays.Days )
	end as Rate
into SickLeavesRates
from (
	select SickLeaves.Ref as Ref, Compensations.Employee as Employee, Compensations.Schedule,
		sum (
			case when Compensations.Days &gt; 0
					and Compensations.Method in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent )
					) then Compensations.Amount / Compensations.Days
				when Compensations.Method = value ( Enum.Calculations.Annual )
					then Compensations.Amount / 12 / case when Compensations.AverageDays = 0 then 1 else Compensations.AverageDays end
				when Compensations.Method = value ( Enum.Calculations.Quarterly )
					then Compensations.Amount / 3 / case when Compensations.AverageDays = 0 then 1 else Compensations.AverageDays end
				else 0
			end
		) as Bonuses,
		sum (
			case when Compensations.Method = value ( Enum.Calculations.Annual )
				then Compensations.Amount
				else 0
			end
		) as AnnualBonuses,
		sum (
			case when Compensations.Method = value ( Enum.Calculations.Quarterly )
				then Compensations.Amount
				else 0
			end
		) as QuarterlyBonuses,
		sum (
			case when Compensations.Method not in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent ),
						value ( Enum.Calculations.Annual ),
						value ( Enum.Calculations.Quarterly )
					) then Compensations.Amount
				else 0
			end
		) as Amount,
		sum (
			case when Compensations.Method in (
						value ( Enum.Calculations.MonthlyRate ),
						value ( Enum.Calculations.HourlyRate )
					) then Compensations.Days
				when Compensations.Method in (
						value ( Enum.Calculations.Vacation ),
						value ( Enum.Calculations.SickDays ),
						value ( Enum.Calculations.SickDaysChild ),
						value ( Enum.Calculations.SickOnlySocial ),
						value ( Enum.Calculations.SickProduction )
					) then Compensations.ScheduledDays
				else 0
			end
		) as Days,
		min ( beginofperiod ( Compensations.DateEnd, month ) ) as DateStart,
		max ( endofperiod ( Compensations.DateEnd, month ) ) as DateEnd
	from PreviousCompensationsForSickLeaves as Compensations
		//
		// BaseCompensations
		//
		join ChartOfCalculationTypes.Compensations.BaseCalculationTypes as BaseCompensations
		on BaseCompensations.CalculationType = Compensations.Compensation
		//
		// SickLeaves
		//
		join (
			select SickLeaves.Ref as Ref, SickLeaves.DateStart as DateStart, SickLeaves.Compensation as Compensation
			from SickLeaves as SickLeaves
			where SickLeaves.OnCompany
			group by SickLeaves.Ref, SickLeaves.DateStart, SickLeaves.Compensation
		) as SickLeaves 
		on SickLeaves.Ref = Compensations.Ref
		and SickLeaves.Compensation = BaseCompensations.Ref
	group by SickLeaves.Ref, beginofperiod ( SickLeaves.DateStart, month ), Compensations.Employee, Compensations.Schedule
	) as Compensations
	//
	// Holidays for base period
	//
	left join (
		select Compensations.Employee as Employee,
			sum ( case when HolidaysList.Day is null then 0 else 1 end ) as Days
		from PreviousCompensationsForSickLeaves as Compensations
			//
			// Schedules
			//
			join InformationRegister.Schedules as Schedules
			on Schedules.Schedule = Compensations.Schedule
			and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
			and Schedules.Day between Compensations.DateStart and Compensations.DateEnd
			//
			// Holidays
			//
			left join AllHolidays as HolidaysList
			on HolidaysList.Reference = Schedules.Schedule.Holidays
			and HolidaysList.Division = Compensations.Division
			and HolidaysList.Day = Schedules.Day
			and Schedules.Minutes &gt; 0
		where Compensations.Compensation.Method in ( value ( Enum.Calculations.MonthlyRate ), value ( Enum.Calculations.HourlyRate ) )
		group by Compensations.Employee
	) as Holidays
	on Holidays.Employee = Compensations.Employee
	//
	// Schedules
	//
	join (
		select Schedules.Ref as Ref, Schedules.Schedule as Schedule, sum ( Schedules.Days ) as Days
		from PreviousSchedulesForSickLeaves as Schedules
		group by Schedules.Ref, Schedules.Schedule
	) as Schedules
	on Schedules.Ref = Compensations.Ref
	and Schedules.Schedule = Compensations.Schedule
index by Employee
;
// SimpleHours
select Location.Employee as Employee, Calendar.Day as Day,
	sum ( case
		when HolidaysList.Day is not null then 0
		when Vacations.Day is not null then 0
		when SickLeaves.Day is not null then 0
		when Schedules.Minutes - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) &lt; 0 then
			0
		else
			Schedules.Minutes - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 )
	end ) / 60 as Hours,		
	sum ( case
		when HolidaysList.Day is not null then 0
		when Vacations.Day is not null then 0
		when SickLeaves.Day is not null then 0
		when Schedules.MinutesEvening + ( Schedules.Minutes - Schedules.MinutesEvening - Schedules.MinutesNight - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) ) &lt; 0 then
			0
		when Schedules.MinutesEvening + ( Schedules.Minutes - Schedules.MinutesEvening - Schedules.MinutesNight - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) ) &gt; Schedules.MinutesEvening then
			Schedules.MinutesEvening
		else
			Schedules.MinutesEvening + ( Schedules.Minutes - Schedules.MinutesEvening - Schedules.MinutesNight - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) )
	end ) / 60 as HoursEvening,
	sum ( case
		when HolidaysList.Day is not null then 0
		when Vacations.Day is not null then 0
		when SickLeaves.Day is not null then 0
		when Schedules.MinutesNight + ( Schedules.MinutesEvening + ( Schedules.Minutes - Schedules.MinutesEvening - Schedules.MinutesNight - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) ) ) &lt; 0 then
			0
		when Schedules.MinutesNight + ( Schedules.MinutesEvening + ( Schedules.Minutes - Schedules.MinutesEvening - Schedules.MinutesNight - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) ) ) &gt; Schedules.MinutesNight then
			Schedules.MinutesNight
		else
			Schedules.MinutesNight + ( Schedules.MinutesEvening + ( Schedules.Minutes - Schedules.MinutesEvening - Schedules.MinutesNight - case when Preholidays.Day is null then 0 else 60 end - isnull ( Absences.Minutes, 0 ) + isnull ( UsedBankHours.Minutes, 0 ) ) )
	end ) / 60 as HoursNight
into SimpleHours
from Location as Location
	//
	// Calendar
	//
	join Calendar as Calendar
	on Calendar.Day between Location.DateStart and Location.DateEnd
	//
	// Filter by NoTimesheets
	//
	join NoTimesheets as NoTimesheets
	on NoTimesheets.Employee = Location.Employee
	//
	// Schedules
	//
	join InformationRegister.Schedules as Schedules
	on Schedules.Schedule = Location.Schedule
	and Schedules.Year in ( Year ( &amp;DateStart ), Year ( &amp;DateEnd ) )
	and Schedules.Day = Calendar.Day
	//
	// Holidays
	//
	left join Holidays as HolidaysList
	on HolidaysList.Schedule = Schedules.Schedule
	and HolidaysList.Division = Location.Department.Division
	and HolidaysList.Day = Schedules.Day
	//
	// Preholidays
	//
	left join Holidays as Preholidays
	on Preholidays.Schedule = Schedules.Schedule
	and Preholidays.Division = Location.Department.Division
	and Preholidays.Preholiday = Schedules.Day
	and Schedules.Minutes &gt; 0
	//
	// Absences
	//
	left join Deviations as Absences
	on Absences.Employee = Location.Employee
	and Absences.Time = value ( Enum.Time.Absence )
	and Absences.Day = Schedules.Day
	and Schedules.Minutes &gt; 0
	//
	// UsedBankHours
	//
	left join Deviations as UsedBankHours
	on UsedBankHours.Employee = Location.Employee
	and UsedBankHours.Time = value ( Enum.Time.BankedUse )
	and UsedBankHours.Day = Schedules.Day
	and Schedules.Minutes &gt; 0
	//
	// Vacations
	//
	left join Vacations as Vacations
	on Vacations.Employee = Location.Employee
	and Vacations.Day = Schedules.Day
	//
	// SickLeaves
	//
	left join SickLeaves as SickLeaves
	on SickLeaves.Employee = Location.Employee
	and SickLeaves.Day = Schedules.Day
group by Location.Employee, Calendar.Day
index by Employee, Day
;
// Hours
select Hours.Employee as Employee, Hours.Day as Day, sum ( Hours.Minutes ) / 60 as Hours,
	case when sum ( Hours.Minutes ) = 0 then 0 else 1 end as Days, 0 as TimeIndex
into Hours
from InformationRegister.Hours as Hours
	//
	// Filter by Employment
	//
	join Employment as Employment
	on Employment.Employee = Hours.Employee
	and Hours.Day between Employment.DateStart and Employment.DateEnd
where Hours.Time in (
	value ( Enum.Time.Billable ),
	value ( Enum.Time.NonBillable ),
	value ( Enum.Time.BankedUse )
	)
group by Hours.Employee, Hours.Day
union all
select SimpleHours.Employee, SimpleHours.Day, SimpleHours.Hours, 1, 0
from SimpleHours as SimpleHours
where SimpleHours.Hours &gt; 0
union all
select SimpleHours.Employee, SimpleHours.Day, SimpleHours.HoursEvening, 1, 1
from SimpleHours as SimpleHours
where SimpleHours.HoursEvening &gt; 0
union all
select SimpleHours.Employee, SimpleHours.Day, SimpleHours.HoursNight, 1, 2
from SimpleHours as SimpleHours
where SimpleHours.HoursNight &gt; 0
index by Employee, Day
;
// Standard
select Location.Employee as Employee, Location.Department as Department, Location.Position as Position,
	Location.Expenses as Expenses, Location.Schedule as Schedule, Location.DateStart as DateStart,
	Location.DateEnd as DateEnd, Location.Hours as Hours, Location.Days as Days, Location.HoursEvening as HoursEvening,
	Location.DaysEvening as DaysEvening, Location.HoursNight as HoursNight, Location.DaysNight as DaysNight,
	Location.Compensation as Compensation, Location.Rate as Rate, Location.InHand as InHand,
	Location.Currency as Currency,
	cast ( case Location.Method
		when value ( Enum.Calculations.HourlyRate ) then Location.Rate
		when value ( Enum.Calculations.MonthlyRate ) then
			case
				when Location.Compensation.HourlyRate = value ( Enum.HourlyRate.Monthly ) then
					case when isnull ( MonthlySchedules.Hours, 0 ) = 0 then 0 else Location.Rate / ( isnull ( MonthlySchedules.Hours, 0 ) - isnull ( MonthlySchedules.HolidaysHours, 0 ) ) end
				else
					case when isnull ( Average.Hours, 0 ) = 0 then 0 else Location.Rate / Average.Hours end
			end
		else 0
	end as Number ( 15, 2 ) ) as HourlyRate,
	case when Location.Method in ( value ( Enum.Calculations.HourlyRate ), value ( Enum.Calculations.MonthlyRate ) ) then isnull ( MonthlySchedules.Hours, 0 ) - isnull ( MonthlySchedules.HolidaysHours, 0 ) else 0 end as ScheduledHours,
	case when Location.Method in ( value ( Enum.Calculations.HourlyRate ), value ( Enum.Calculations.MonthlyRate ), value ( Enum.Calculations.Amount ) ) then isnull ( MonthlySchedules.Days, 0 ) - isnull ( MonthlySchedules.HolidaysDays, 0 ) else 0 end as ScheduledDays,
	case when Location.Method = value ( Enum.Calculations.EveningHours ) then isnull ( Schedules.HoursEvening, 0 ) else 0 end as ScheduledEveningHours,
	case when Location.Method = value ( Enum.Calculations.EveningHours ) then isnull ( Schedules.DaysEvening, 0 ) else 0 end as ScheduledEveningDays,
	case when Location.Method = value ( Enum.Calculations.NightHours ) then isnull ( Schedules.HoursNight, 0 ) else 0 end as ScheduledNightHours,
	case when Location.Method = value ( Enum.Calculations.NightHours ) then isnull ( Schedules.DaysNight, 0 ) else 0 end as ScheduledNightDays
into Standard
from (
	select Location.Employee as Employee, Location.Department as Department, Location.Position as Position,
		Location.Expenses as Expenses, Location.Schedule as Schedule,
		case when Location.DateStart &gt; Compensations.DateStart then Location.DateStart else Compensations.DateStart end as DateStart,
		case when Location.DateEnd &gt; Compensations.DateEnd then Compensations.DateEnd else Location.DateEnd end as DateEnd,
		Compensations.Compensation as Compensation, Compensations.Rate as Rate, Compensations.InHand as InHand,
		Compensations.Currency as Currency, Compensations.Compensation.Method as Method,
		sum ( case when GeneralHours.TimeIndex = 0 then GeneralHours.Hours else 0 end ) as Hours,
		sum ( case when GeneralHours.TimeIndex = 0 then GeneralHours.Days else 0 end ) as Days,
		sum ( case when GeneralHours.TimeIndex = 1 then GeneralHours.Hours else 0 end ) as HoursEvening,
		sum ( case when GeneralHours.TimeIndex = 1 then GeneralHours.Days else 0 end ) as DaysEvening,
		sum ( case when GeneralHours.TimeIndex = 2 then GeneralHours.Hours else 0 end ) as HoursNight,
		sum ( case when GeneralHours.TimeIndex = 2 then GeneralHours.Days else 0 end ) as DaysNight
	from Location as Location
		//
		// Compensations
		//
		join Compensations as Compensations
		on Compensations.Employee = Location.Employee
		and ( Location.DateStart between Compensations.DateStart and Compensations.DateEnd
			or Location.DateEnd between Compensations.DateStart and Compensations.DateEnd )
		//
		// GeneralHours
		//
		left join Hours as GeneralHours
		on GeneralHours.Employee = Location.Employee
		and GeneralHours.Day between
			case when Location.DateStart &gt; Compensations.DateStart then Location.DateStart else Compensations.DateStart end
			and
			case when Location.DateEnd &gt; Compensations.DateEnd then Compensations.DateEnd else Location.DateEnd end
	group by Location.Employee, Location.Department, Location.Position, Location.Expenses, Location.Schedule,
		case when Location.DateStart &gt; Compensations.DateStart then Location.DateStart else Compensations.DateStart end,
		case when Location.DateEnd &gt; Compensations.DateEnd then Compensations.DateEnd else Location.DateEnd end,
		Compensations.Compensation, Compensations.Currency, Compensations.Rate, Compensations.InHand
	) as Location
	//
	// Schedules
	//
	left join Schedules as Schedules
	on Schedules.Schedule = Location.Schedule
	and Schedules.Division = Location.Department.Division
	and Schedules.DateStart = Location.DateStart
	and Schedules.DateEnd = Location.DateEnd
	//
	// MonthlySchedules
	//
	left join Schedules as MonthlySchedules
	on MonthlySchedules.Schedule = Location.Schedule
	and MonthlySchedules.Division = Location.Department.Division
	and MonthlySchedules.DateStart = &amp;StartMonth
	and MonthlySchedules.DateEnd = &amp;EndMonth
	//
	// Average
	//
	left join Average as Average
	on Average.Schedule = Location.Schedule
	and Average.Division = Location.Department.Division
index by Employee
;
// ExchangeRates
select ExchangeRates.Currency as Currency, ExchangeRates.Rate as Rate, ExchangeRates.Factor as Factor
into ExchangeRates
from InformationRegister.ExchangeRates.SliceLast ( &amp;DateEnd ) as ExchangeRates
index by Currency
;
// BaseCalculationTypes
select Base.Ref as Ref, Base.CalculationType as CalculationType
into BaseCalculationTypes
from ChartOfcalculationTypes.Compensations.BaseCalculationTypes as Base
union
select Compensations.Ref, Base.Ref
from ChartOfcalculationTypes.Compensations as Compensations
	//
	// Default Base
	//
	join ChartOfcalculationTypes.Compensations as Base
	on Base.Method in (
		value ( Enum.Calculations.MonthlyRate ),
		value ( Enum.Calculations.HourlyRate ) )
	and Compensations.Method in (
		value ( Enum.Calculations.EveningHours ),
		value ( Enum.Calculations.NightHours ),
		value ( Enum.Calculations.HolidayHours ),
		value ( Enum.Calculations.DayOff ),
		value ( Enum.Calculations.Overtime ) )
;
// Levels
select Level0.Ref as Compensation,
	max (
		case
			when Level3.Ref is not null then 3
			when Level2.Ref is not null then 2
			when Level1.Ref is not null then 1
			else 0
		end ) as Level
into Levels
from ChartOfcalculationTypes.Compensations as Level0
	//
	// Level1
	//
	left join BaseCalculationTypes as Level1
	on Level1.Ref = Level0.Ref
	//
	// Level2
	//
	left join BaseCalculationTypes as Level2
	on Level2.Ref = Level1.CalculationType
	//
	// Level3
	//
	left join BaseCalculationTypes as Level3
	on Level3.Ref = Level2.CalculationType
where Level0.Method not in (
	value ( Enum.Calculations.Vacation ),
	value ( Enum.Calculations.ExtendedVacation ),
	value ( Enum.Calculations.SickDays ),
	value ( Enum.Calculations.SickDaysChild ),
	value ( Enum.Calculations.SickOnlySocial ),
	value ( Enum.Calculations.SickProduction )
)
and not &amp;TaxesOnly
group by Level0.Ref
union all
select Level0.Ref, 0
from ChartOfcalculationTypes.Compensations as Level0
where Level0.Method in (
	value ( Enum.Calculations.Vacation ),
	value ( Enum.Calculations.ExtendedVacation ),
	value ( Enum.Calculations.SickDays ),
	value ( Enum.Calculations.SickDaysChild ),
	value ( Enum.Calculations.SickOnlySocial ),
	value ( Enum.Calculations.SickProduction )
)
and not &amp;TaxesOnly
index by Compensation
;
// Seniority
select cast ( Seniority.Value as Number ( 5, 2 ) ) as Value
into Seniority
from InformationRegister.Settings.SliceLast ( &amp;DateEnd,
	Parameter = value ( ChartOfCharacteristicTypes.Settings.SeniorityAmendment ) ) as Seniority
;
// Records
select Time.Employee as Employee, Time.Department as Department, Time.Position as Position,
	Time.Schedule as Schedule, Time.DateStart as DateStart, Time.DateEnd as DateEnd, Time.Compensation as Compensation,
	Time.InHand as InHand, Time.Currency as Currency, Time.Compensation.Method as Method, Levels.Level as Level,
	Time.HourlyRate as HourlyRate, Time.Reference, Time.DailyRate as DailyRate, Time.BaseAmount as BaseAmount,
	Time.BaseDays as BaseDays, Time.Bonuses as Bonuses, Time.BasePeriod as BasePeriod, Time.BaseHolidays as BaseHolidays,
	Time.Compensation.Account as Account, Time.Expenses as Expenses,
	Time.AnnualBonuses as AnnualBonuses, Time.QuarterlyBonuses as QuarterlyBonuses,
	Time.BaseScheduledDays as BaseScheduledDays, Time.Holidays as Holidays, Time.OnCompany as OnCompany,
	case
		when Time.Compensation.Method = value ( Enum.Calculations.DayOff )
			or Time.Compensation.Method = value ( Enum.Calculations.HolidayHours ) then
			Time.Schedule.DaysOffCoef
		else
			Time.Rate
	end as Rate,
	case Time.Compensation.Method
	 	when value ( Enum.Calculations.MonthlyRate ) then 0
		when value ( Enum.Calculations.HourlyRate ) then 1
		when value ( Enum.Calculations.EveningHours ) then 2
		when value ( Enum.Calculations.NightHours ) then 3
		else 4
	end as Priority,
	case Time.Compensation.Method
		when value ( Enum.Calculations.EveningHours ) then Time.HoursEvening
		when value ( Enum.Calculations.NightHours ) then Time.HoursNight
		when value ( Enum.Calculations.FixedAmount ) then 0
		when value ( Enum.Calculations.Amount ) then 0
		when value ( Enum.Calculations.CompensationPercent ) then 0
		else Time.Hours
	end as Hours,
	case Time.Compensation.Method
		when value ( Enum.Calculations.EveningHours ) then Time.DaysEvening
		when value ( Enum.Calculations.NightHours ) then Time.DaysNight
		when value ( Enum.Calculations.FixedAmount ) then 0
		when value ( Enum.Calculations.Amount ) then 0
		when value ( Enum.Calculations.CompensationPercent ) then 0
		else Time.Days
	end as Days,
	case Time.Compensation.Method
		when value ( Enum.Calculations.EveningHours ) then Time.ScheduledEveningHours
		when value ( Enum.Calculations.NightHours ) then Time.ScheduledNightHours
		else Time.ScheduledHours
	end as ScheduledHours,
	case Time.Compensation.Method
		when value ( Enum.Calculations.EveningHours ) then Time.ScheduledEveningDays
		when value ( Enum.Calculations.NightHours ) then Time.ScheduledNightDays
		else Time.ScheduledDays
	end as ScheduledDays,
	cast (
		case Time.Compensation.Method
			when value ( Enum.Calculations.MonthlyRate ) then
				case when Time.ScheduledHours = 0 then 0
					when Time.ScheduledHours = Time.Hours then Time.Rate
					else Time.Rate / Time.ScheduledHours * Time.Hours
				end
			when value ( Enum.Calculations.HourlyRate ) then
				Time.Rate * Time.Hours
			when value ( Enum.Calculations.FixedAmount ) then
				case when LastLocation.Employee is null then 0 else Time.Rate end
			when value ( Enum.Calculations.Amount ) then
				case Time.ScheduledDays when 0 then 0 else Time.Rate / Time.ScheduledDays * Time.Days end
			when value ( Enum.Calculations.CompensationPercent ) then
				case when LastLocation.Employee is null then 0 else MainRates.Rate / 100 * Time.Rate end
			when value ( Enum.Calculations.Vacation ) then
				Time.DailyRate * Time.Days
			when value ( Enum.Calculations.SickDays ) then
				Time.DailyRate * Time.Days * ( Seniority.Value / 100 )
			when value ( Enum.Calculations.SickProduction ) then
				Time.DailyRate * Time.Days * ( Seniority.Value / 100 )
			else 0                                        
		end as Number ( 15, 2 ) ) as Result,
	cast (
		case Time.Compensation.Method
			when value ( Enum.Calculations.MonthlyRate ) then
				case when Time.ScheduledHours = 0 then 0
					when Time.ScheduledHours = Time.Hours then Time.Rate
					else Time.Rate / Time.ScheduledHours * Time.Hours
				end
			when value ( Enum.Calculations.HourlyRate ) then
				Time.Rate * Time.Hours
			when value ( Enum.Calculations.FixedAmount ) then
				case when LastLocation.Employee is null then 0 else Time.Rate end
			when value ( Enum.Calculations.Amount ) then
				case Time.ScheduledDays when 0 then 0 else Time.Rate / Time.ScheduledDays * Time.Days end
			when value ( Enum.Calculations.CompensationPercent ) then
				case when LastLocation.Employee is null then 0 else MainRates.Rate / 100 * Time.Rate end
			when value ( Enum.Calculations.Vacation ) then
				Time.DailyRate * Time.Days
			when value ( Enum.Calculations.SickDays ) then
				Time.DailyRate * Time.Days * ( Seniority.Value / 100 )
			when value ( Enum.Calculations.SickProduction ) then
				Time.DailyRate * Time.Days * ( Seniority.Value / 100 )
			else 0
		end
		* isnull ( ExchangeRates.Rate, 1 ) / isnull ( ExchangeRates.Factor, 1 ) as Number ( 15, 2 ) ) as AccountingResult
into Records
from (
	select Standard.Employee as Employee, Standard.Department as Department, Standard.Position as Position,
		Standard.Expenses as Expenses, Standard.Schedule as Schedule, Standard.DateStart as DateStart,
		Standard.DateEnd as DateEnd, Standard.Compensation as Compensation, Standard.Rate as Rate, Standard.InHand as InHand,
		Standard.Currency as Currency, Standard.ScheduledHours as ScheduledHours, Standard.ScheduledDays as ScheduledDays,
		Standard.ScheduledEveningHours as ScheduledEveningHours, Standard.ScheduledEveningDays as ScheduledEveningDays,
		Standard.ScheduledNightHours as ScheduledNightHours, Standard.ScheduledNightDays as ScheduledNightDays,
		Standard.Hours as Hours, Standard.Days as Days,
		Standard.HoursEvening as HoursEvening, Standard.DaysEvening as DaysEvening,
		Standard.HoursNight as HoursNight, Standard.DaysNight as DaysNight, Standard.HourlyRate as HourlyRate,
		0 as DailyRate, 0 as BaseAmount, 0 as BaseDays, 0 as Bonuses, 0 as BasePeriod, 0 as BaseHolidays,
		undefined as Reference, 0 as AnnualBonuses, 0 as QuarterlyBonuses,
		0 as BaseScheduledDays, 0 as Holidays, false as OnCompany
	from Standard as Standard
	union all
	select Vacations.Employee, Vacations.Department, Vacations.Position, Vacations.Expenses, Vacations.Schedule,
		Vacations.DateStart, Vacations.DateEnd, Vacations.Compensation, 0, false, Constants.Currency,
		Vacations.ScheduledHours, Vacations.ScheduledDays,
		0, 0, 0, 0, 0, Vacations.Days, 0, 0, 0, 0, 0,
		VacationRates.Rate, VacationRates.Amount, VacationRates.Days, VacationRates.Bonuses, VacationRates.Period, VacationRates.Holidays,
		Vacations.Ref, VacationRates.AnnualBonuses, VacationRates.QuarterlyBonuses, VacationRates.ScheduledDays, Vacations.Holidays,
		false
	from (
		select Vacations.Ref as Ref, Location.Employee as Employee, Location.Department as Department, Location.Position as Position,
			Location.Expenses as Expenses, Location.Schedule as Schedule, Vacations.Compensation as Compensation,
			min ( Vacations.Day ) as DateStart, max ( Vacations.Day ) as DateEnd,
			sum ( Vacations.ScheduledMinutes / 60 ) as ScheduledHours,
			sum ( case when Vacations.ScheduledMinutes = 0 then 0 else 1 end ) as ScheduledDays,
			count ( Vacations.Day ) - count ( Vacations.Holiday ) as Days,
			count ( Vacations.Holiday ) as Holidays
		from ScheduledLocation as Location
			//
			// Vacations
			//
			join Vacations as Vacations
			on Vacations.Employee = Location.Employee
			and Vacations.Day between Location.DateStart and Location.DateEnd
		group by Vacations.Ref, Location.Employee, Location.Department, Location.Position, 
			Location.Expenses, Location.Schedule, Vacations.Compensation
		) as Vacations
		//
		// VacationRates
		//
		join VacationRates as VacationRates
		on VacationRates.Employee = Vacations.Employee
		and VacationRates.Ref = Vacations.Ref
		//
		// Constants
		//
		join Constants as Constants
		on true
	union all
	select SickLeaves.Employee, SickLeaves.Department, SickLeaves.Position, SickLeaves.Expenses, SickLeaves.Schedule,
		SickLeaves.DateStart, SickLeaves.DateEnd, SickLeaves.Compensation, 0, false, Constants.Currency,
		SickLeaves.ScheduledHours, SickLeaves.ScheduledDays,
		0, 0, 0, 0, 0, SickLeaves.Days, 0, 0, 0, 0, 0,
		SickLeavesRates.Rate * SickLeaves.OnCompany, SickLeavesRates.Amount * SickLeaves.OnCompany, SickLeavesRates.Days,
		SickLeavesRates.Bonuses * SickLeaves.OnCompany, SickLeavesRates.Period, SickLeavesRates.Holidays,
		SickLeaves.Ref, SickLeavesRates.AnnualBonuses * SickLeaves.OnCompany,
		SickLeavesRates.QuarterlyBonuses * SickLeaves.OnCompany, SickLeavesRates.ScheduledDays, 0, SickLeaves.OnCompany = 1
	from (
		select SickLeaves.Ref as Ref, Location.Employee as Employee, Location.Department as Department, Location.Position as Position,
			Location.Expenses as Expenses, Location.Schedule as Schedule, SickLeaves.Compensation as Compensation,
			min ( SickLeaves.Day ) as DateStart, max ( SickLeaves.Day ) as DateEnd,
			sum ( SickLeaves.ScheduledMinutes / 60 ) as ScheduledHours,
			sum ( case when SickLeaves.ScheduledMinutes = 0 then 0 else 1 end ) as ScheduledDays,
			count ( SickLeaves.Day ) as Days, case when SickLeaves.OnCompany then 1 else 0 end as OnCompany
		from ScheduledLocation as Location
			//
			// SickLeaves
			//
			join SickLeaves as SickLeaves
			on SickLeaves.Employee = Location.Employee
			and SickLeaves.Day between Location.DateStart and Location.DateEnd
		group by Location.Employee, Location.Department, Location.Position, Location.Expenses, Location.Schedule,
			Location.DateStart, Location.DateEnd, SickLeaves.SpanStart, SickLeaves.SpanEnd, SickLeaves.Compensation,
			SickLeaves.Ref, SickLeaves.OnCompany
		) as SickLeaves
		//
		// SickLeavesRates
		//
		left join SickLeavesRates as SickLeavesRates
		on SickLeavesRates.Employee = SickLeaves.Employee
		and SickLeavesRates.Ref = SickLeaves.Ref
		//
		// Constants
		//
		join Constants as Constants
		on true
	union all
	select Standard.Employee, Standard.Department, Standard.Position, Standard.Expenses, Standard.Schedule,
		min ( Deviations.Day ), max ( Deviations.Day ), OtherCompensations.Compensation, 0, Standard.InHand, Standard.Currency,
		0, 0, 0, 0, 0, 0,
		sum ( Deviations.Minutes ) / 60, sum ( case when Deviations.Minutes = 0 then 0 else 1 end ),
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, undefined, 0, 0, 0, 0, false
	from Standard as Standard
		//
		// Deviations
		//
		join Deviations as Deviations
		on Deviations.Employee = Standard.Employee
		and Deviations.Day between Standard.DateStart and Standard.DateEnd
		//
		// OtherCompensations
		//
		left join OtherCompensations as OtherCompensations
		on OtherCompensations.Time = Deviations.Time
	where Standard.Compensation.Method in ( value ( Enum.Calculations.HourlyRate ), value ( Enum.Calculations.MonthlyRate ) )
	group by Standard.Employee, Standard.Department, Standard.Position, Standard.Expenses, Standard.Schedule,
		Standard.DateStart, Standard.DateEnd, OtherCompensations.Compensation, Standard.Rate,
		Standard.InHand, Standard.Currency
	) as Time
	//
	// MainRates
	//
	left join Standard as MainRates
	on MainRates.Employee = Time.Employee
	and MainRates.Department = Time.Department
	and MainRates.Position = Time.Position
	and MainRates.Expenses = Time.Expenses
	and MainRates.Schedule = Time.Schedule
	and MainRates.DateStart = Time.DateStart
	and MainRates.DateEnd = Time.DateEnd
	and MainRates.Currency = Time.Currency
	and MainRates.Compensation.Method in (
		value ( Enum.Calculations.MonthlyRate ),
		value ( Enum.Calculations.HourlyRate )
	)
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Time.Currency
	//
	// Levels
	//
	left join Levels as Levels
	on Levels.Compensation = Time.Compensation
	//
	// LastLocation
	//
	left join LastLocation as LastLocation
	on LastLocation.DateEnd = Time.DateEnd
	and LastLocation.Employee = Time.Employee
	and LastLocation.Department = Time.Department
	and LastLocation.Position = Time.Position
	and LastLocation.Schedule = Time.Schedule
	and LastLocation.Expenses = Time.Expenses
	//
	// Calculated
	//
	left join Document.Payroll.Compensations as Calculated
	on Calculated.Ref.DateStart = &amp;DateStart
	and Calculated.Ref.DateEnd = &amp;DateEnd
	and Calculated.Employee = Time.Employee
	and Calculated.Compensation = Time.Compensation
	and Calculated.Department = Time.Department
	and Calculated.Position = Time.Position
	and Calculated.Expenses = Time.Expenses
	and Calculated.Schedule = Time.Schedule
	and Calculated.DateStart = Time.DateStart
	and Calculated.DateEnd = Time.DateEnd
	and Calculated.Reference = Time.Reference
	and Calculated.Ref.Posted
	and Calculated.Ref &lt;&gt; &amp;Ref
	//
	// Seniority
	//
	left join Seniority as Seniority
	on true
where Calculated.Ref is null
;
// BaseCompensations
select Records.Level as Level, Records.Employee as Employee, Records.Compensation as Compensation,
	Records.DateStart as DateStart, Records.DateEnd as DateEnd, Records.Rate as Rate, Records.Currency as Currency,
	Records.OnCompany as OnCompany, Base.CalculationType as BaseCompensation
into BaseCompensations
from Records as Records
	//
	// Base
	//
	join ChartOfcalculationTypes.Compensations.BaseCalculationTypes as Base
	on Base.Ref = Records.Compensation
union
select Records.Level, Records.Employee, Records.Compensation, Records.DateStart, Records.DateEnd, Records.Rate, 
	Records.Currency, Records.OnCompany, Base.Ref
from Records as Records
	//
	// Base
	//
	join ChartOfcalculationTypes.Compensations as Base
	on Base.Method in ( value ( Enum.Calculations.MonthlyRate ), value ( Enum.Calculations.HourlyRate ) )
where Records.Compensation.Method in (
	value ( Enum.Calculations.EveningHours ),
	value ( Enum.Calculations.NightHours ),
	value ( Enum.Calculations.HolidayHours ),
	value ( Enum.Calculations.DayOff ),
	value ( Enum.Calculations.Overtime )
	)
index by Employee, BaseCompensation
;
// Calculations0
select Records.Employee as Employee, Records.Department as Department, Records.Position as Position,
	Records.Expenses as Expenses, Records.Schedule as Schedule, Records.DateStart as DateStart, Records.DateEnd as DateEnd,
	Records.Compensation as Compensation, Records.Rate as Rate, Records.InHand as InHand, Records.Currency as Currency,
	Records.ScheduledHours as ScheduledHours, Records.ScheduledDays as ScheduledDays,
	Records.Hours as Hours, Records.Days as Days, Records.Account as Account, Records.Priority as Priority,
	Records.HourlyRate as HourlyRate, Records.Result as Result, Records.AccountingResult as AccountingResult,
	Records.DailyRate as DailyRate, Records.BaseAmount as BaseAmount, Records.BaseDays as BaseDays, Records.Bonuses as Bonuses,
	Records.BasePeriod as BasePeriod, Records.BaseHolidays as BaseHolidays, Records.Reference as Reference,
	Records.AnnualBonuses as AnnualBonuses, Records.QuarterlyBonuses as QuarterlyBonuses, Records.Holidays as Holidays, Records.BaseScheduledDays as BaseScheduledDays,
	Records.OnCompany as OnCompany
into Calculations0
from Records as Records
where Records.Level = 0
;
// Calculations1
select Records.Employee as Employee, Records.Department as Department, Records.Position as Position,
	Records.Expenses as Expenses, Records.Schedule as Schedule, Records.DateStart as DateStart, Records.DateEnd as DateEnd,
	Records.Compensation as Compensation, Records.Rate as Rate, Records.InHand as InHand, Records.Currency as Currency,
	Records.ScheduledHours as ScheduledHours, Records.ScheduledDays as ScheduledDays,
	Records.Hours as Hours, Records.Days as Days, Records.Account as Account, Records.Priority as Priority,
	Records.HourlyRate as HourlyRate, Records.AnnualBonuses as AnnualBonuses, Records.QuarterlyBonuses as QuarterlyBonuses,
	Records.Holidays as Holidays, Records.BaseScheduledDays as BaseScheduledDays, Records.OnCompany as OnCompany,
	cast (
		case
			when Records.Method = value ( Enum.Calculations.EveningHours )
				or Records.Method = value ( Enum.Calculations.NightHours ) then
				case when isnull ( Basis.Hours, 0 ) = 0 then 0
					else Basis.Base / Basis.Hours * Records.Hours / 100 * Records.Rate
				end
			when Records.Method = value ( Enum.Calculations.Percent ) then
				Basis.Base / 100 * Records.Rate
			when Records.Method = value ( Enum.Calculations.Overtime ) then
				case
					when Records.Schedule.UseOvertime then
						Records.Schedule.OvertimeCoef1 * Basis.HourlyRate *
						case when Records.Hours &gt; Records.Schedule.OvertimeLimit then Records.Schedule.OvertimeLimit
							else Records.Hours
						end
						+
						Records.Schedule.OvertimeCoef2 * Basis.HourlyRate *
						case when Records.Hours &gt; Records.Schedule.OvertimeLimit then Records.Hours - Records.Schedule.OvertimeLimit
							else 0
						end
					else
						0
				end
			when Records.Method = value ( Enum.Calculations.HolidayHours )
				or Records.Method = value ( Enum.Calculations.DayOff ) then
				Basis.HourlyRate * Records.Rate * Records.Hours
			else
				Records.Result
		end as Number ( 15, 2 ) ) as Result,
	cast (
		cast (
			case
				when Records.Method = value ( Enum.Calculations.EveningHours )
					or Records.Method = value ( Enum.Calculations.NightHours ) then
					case when isnull ( Basis.Hours, 0 ) = 0 then 0
						else Basis.Base / Basis.Hours * Records.Hours / 100 * Records.Rate
					end
				when Records.Method = value ( Enum.Calculations.Percent ) then
					Basis.Base / 100 * Records.Rate
				when Records.Method = value ( Enum.Calculations.Overtime ) then
					case
						when Records.Schedule.UseOvertime then
							Records.Schedule.OvertimeCoef1 * Basis.HourlyRate *
							case when Records.Hours &gt; Records.Schedule.OvertimeLimit then Records.Schedule.OvertimeLimit
								else Records.Hours
							end
							+
							Records.Schedule.OvertimeCoef2 * Basis.HourlyRate *
							case when Records.Hours &gt; Records.Schedule.OvertimeLimit then Records.Hours - Records.Schedule.OvertimeLimit
								else 0
							end
						else
							0
					end
				when Records.Method = value ( Enum.Calculations.HolidayHours )
					or Records.Method = value ( Enum.Calculations.DayOff ) then
					Basis.HourlyRate * Records.Rate * Records.Hours
				else
					Records.Result
			end as Number ( 15, 2 ) )
		* isnull ( ExchangeRates.Rate, 1 ) / isnull ( ExchangeRates.Factor, 1 ) as Number ( 15, 2 ) ) as AccountingResult
into Calculations1
from Records as Records
	//
	// Basis
	//
	left join (
		select Basis.Employee as Employee, Basis.DateStart as DateStart, Basis.DateEnd as DateEnd,
			Basis.Compensation as Compensation, Basis.HourlyRate as HourlyRate, sum ( Basis.Base ) as Base,
			sum ( Basis.Hours ) as Hours, sum ( Basis.ScheduledHours ) as ScheduledHours
		from (
			select BaseCompensations.Employee as Employee, BaseCompensations.DateStart as DateStart, BaseCompensations.DateEnd as DateEnd,
				BaseCompensations.Compensation as Compensation, Records.Hours as Hours, Records.ScheduledHours as ScheduledHours,
				Records.HourlyRate as HourlyRate,
				case Records.Currency
					when BaseCompensations.Currency then Records.Result
					else Records.AccountingResult / isnull ( ExchangeRates.Rate, 1 ) * isnull ( ExchangeRates.Factor, 1 )
				end as Base
			from Calculations0 as Records
				//
				// Base
				//
				join BaseCompensations as BaseCompensations
				on BaseCompensations.Employee = Records.Employee
				and BaseCompensations.BaseCompensation = Records.Compensation
				and BaseCompensations.DateStart &gt;= Records.DateStart
				and BaseCompensations.DateEnd &lt;= Records.DateEnd
				and BaseCompensations.Level = 1
				//
				// ExchangeRates
				//
				left join ExchangeRates as ExchangeRates
				on ExchangeRates.Currency = BaseCompensations.Currency
			union all
			select Compensations.Employee, Compensations.DateStart, Compensations.DateEnd, Compensations.Compensation,
				Compensations.Hours, Compensations.ScheduledHours, Compensations.HourlyRate,
				case Compensations.Currency
					when BaseCompensations.Currency then Compensations.Result
					else Compensations.AccountingResult / isnull ( ExchangeRates.Rate, 1 ) * isnull ( ExchangeRates.Factor, 1 )
				end
			from Document.Payroll.Compensations as Compensations
				//
				// Base
				//
				join BaseCompensations as BaseCompensations
				on BaseCompensations.Employee = Compensations.Employee
				and BaseCompensations.BaseCompensation = Compensations.Compensation
				and BaseCompensations.DateStart &gt;= Compensations.DateStart
				and BaseCompensations.DateEnd &lt;= Compensations.DateEnd
				and BaseCompensations.Level = 1
				//
				// ExchangeRates
				//
				left join ExchangeRates as ExchangeRates
				on ExchangeRates.Currency = BaseCompensations.Currency
			where Compensations.Ref.Date between &amp;DateStart and &amp;DateEnd
			and Compensations.Ref.Posted
			) as Basis
		group by Basis.Employee, Basis.DateStart, Basis.DateEnd, Basis.Compensation, Basis.HourlyRate
		) as Basis
	on Basis.Employee = Records.Employee
	and Basis.Compensation = Records.Compensation
	and Basis.DateStart = Records.DateStart
	and Basis.DateEnd = Records.DateEnd
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Records.Currency
where Records.Level = 1
;
// Calculations2
select Records.Employee as Employee, Records.Department as Department, Records.Position as Position,
	Records.Expenses as Expenses, Records.Schedule as Schedule, Records.DateStart as DateStart, Records.DateEnd as DateEnd,
	Records.Compensation as Compensation, Records.Rate as Rate, Records.InHand as InHand, Records.Currency as Currency,
	Records.ScheduledHours as ScheduledHours, Records.ScheduledDays as ScheduledDays,
	Records.Hours as Hours, Records.Days as Days, Records.Account as Account, Records.Priority as Priority,
	Records.HourlyRate as HourlyRate, Records.AnnualBonuses as AnnualBonuses, Records.QuarterlyBonuses as QuarterlyBonuses,
	Records.Holidays as Holidays, Records.BaseScheduledDays as BaseScheduledDays, Records.OnCompany as OnCompany,
	cast (
		case
			when Records.Method = value ( Enum.Calculations.Percent ) then
				Basis.Base / 100 * Records.Rate
			else
				Records.Result
		end as Number ( 15, 2 ) ) as Result,
	cast (
		case
			when Records.Method = value ( Enum.Calculations.Percent ) then
				Basis.Base / 100 * Records.Rate
			else
				Records.Result
		end
		* isnull ( ExchangeRates.Rate, 1 ) / isnull ( ExchangeRates.Factor, 1 ) as Number ( 15, 2 ) ) as AccountingResult
into Calculations2
from Records as Records
	//
	// Basis
	//
	left join (
		select Basis.Employee as Employee, Basis.DateStart as DateStart, Basis.DateEnd as DateEnd,
			Basis.Compensation as Compensation, sum ( Basis.Base ) as Base, sum ( Basis.Hours ) as Hours
		from (
			select BaseCompensations.Employee as Employee, BaseCompensations.DateStart as DateStart, BaseCompensations.DateEnd as DateEnd,
				BaseCompensations.Compensation as Compensation, Records.Hours as Hours,
				case Records.Currency
					when BaseCompensations.Currency then Records.Result
					else Records.AccountingResult / isnull ( ExchangeRates.Rate, 1 ) * isnull ( ExchangeRates.Factor, 1 )
				end as Base
			from (
				select Records.Employee as Employee, Records.Compensation as Compensation, Records.DateStart as DateStart,
					Records.DateEnd as DateEnd, Records.Hours as Hours, Records.Currency as Currency,
					Records.Result as Result, Records.AccountingResult as AccountingResult
				from Calculations0 as Records
				union all
				select Records.Employee, Records.Compensation, Records.DateStart, Records.DateEnd,
					Records.Hours, Records.Currency, Records.Result, Records.AccountingResult
				from Calculations1 as Records
				) as Records
				//
				// Base
				//
				join BaseCompensations as BaseCompensations
				on BaseCompensations.Employee = Records.Employee
				and BaseCompensations.BaseCompensation = Records.Compensation
				and BaseCompensations.DateStart &gt;= Records.DateStart
				and BaseCompensations.DateEnd &lt;= Records.DateEnd
				and BaseCompensations.Level = 2
				//
				// ExchangeRates
				//
				left join ExchangeRates as ExchangeRates
				on ExchangeRates.Currency = BaseCompensations.Currency
			union all
			select Compensations.Employee, Compensations.DateStart, Compensations.DateEnd,
				Compensations.Compensation, Compensations.Hours,
				case Compensations.Currency
					when BaseCompensations.Currency then Compensations.Result
					else Compensations.AccountingResult / isnull ( ExchangeRates.Rate, 1 ) * isnull ( ExchangeRates.Factor, 1 )
				end
			from Document.Payroll.Compensations as Compensations
				//
				// Base
				//
				join BaseCompensations as BaseCompensations
				on BaseCompensations.Employee = Compensations.Employee
				and BaseCompensations.BaseCompensation = Compensations.Compensation
				and BaseCompensations.DateStart &gt;= Compensations.DateStart
				and BaseCompensations.DateEnd &lt;= Compensations.DateEnd
				and BaseCompensations.Level = 2
				//
				// ExchangeRates
				//
				left join ExchangeRates as ExchangeRates
				on ExchangeRates.Currency = BaseCompensations.Currency
			where Compensations.Ref.Date between &amp;DateStart and &amp;DateEnd
			and Compensations.Ref.Posted
			) as Basis
		group by Basis.Employee, Basis.DateStart, Basis.DateEnd, Basis.Compensation
		) as Basis
	on Basis.Employee = Records.Employee
	and Basis.Compensation = Records.Compensation
	and Basis.DateStart = Records.DateStart
	and Basis.DateEnd = Records.DateEnd
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Records.Currency
where Records.Level = 2
;
// Calculations3
select Records.Employee as Employee, Records.Department as Department, Records.Position as Position,
	Records.Expenses as Expenses, Records.Schedule as Schedule, Records.DateStart as DateStart, Records.DateEnd as DateEnd,
	Records.Compensation as Compensation, Records.Rate as Rate, Records.InHand as InHand, Records.Currency as Currency,
	Records.ScheduledHours as ScheduledHours, Records.ScheduledDays as ScheduledDays,
	Records.Hours as Hours, Records.Days as Days, Records.Account as Account, Records.Priority as Priority,
	Records.HourlyRate as HourlyRate, Records.AnnualBonuses as AnnualBonuses, Records.QuarterlyBonuses as QuarterlyBonuses,
	Records.Holidays as Holidays, Records.BaseScheduledDays as BaseScheduledDays, Records.OnCompany as OnCompany,
	cast (
		case
			when Records.Method = value ( Enum.Calculations.Percent ) then
				Basis.Base / 100 * Records.Rate
			else
				Records.Result
		end as Number ( 15, 2 ) ) as Result,
	cast (
		case
			when Records.Method = value ( Enum.Calculations.Percent ) then
				Basis.Base / 100 * Records.Rate
			else
				Records.Result
		end
		* isnull ( ExchangeRates.Rate, 1 ) / isnull ( ExchangeRates.Factor, 1 ) as Number ( 15, 2 ) ) as AccountingResult
into Calculations3
from Records as Records
	//
	// Basis
	//
	left join (
		select Basis.Employee as Employee, Basis.DateStart as DateStart, Basis.DateEnd as DateEnd,
			Basis.Compensation as Compensation, sum ( Basis.Base ) as Base, sum ( Basis.Hours ) as Hours
		from (
			select BaseCompensations.Employee as Employee, BaseCompensations.DateStart as DateStart, BaseCompensations.DateEnd as DateEnd,
				BaseCompensations.Compensation as Compensation, Records.Hours as Hours,
				case Records.Currency
					when BaseCompensations.Currency then Records.Result
					else Records.AccountingResult / isnull ( ExchangeRates.Rate, 1 ) * isnull ( ExchangeRates.Factor, 1 )
				end as Base
			from (
				select Records.Employee as Employee, Records.Compensation as Compensation, Records.DateStart as DateStart,
					Records.DateEnd as DateEnd, Records.Hours as Hours, Records.Currency as Currency,
					Records.Result as Result, Records.AccountingResult as AccountingResult
				from Calculations0 as Records
				union all
				select Records.Employee, Records.Compensation, Records.DateStart, Records.DateEnd,
					Records.Hours, Records.Currency, Records.Result, Records.AccountingResult
				from Calculations1 as Records
				union all
				select Records.Employee, Records.Compensation, Records.DateStart, Records.DateEnd,
					Records.Hours, Records.Currency, Records.Result, Records.AccountingResult
				from Calculations2 as Records
				) as Records
				//
				// Base
				//
				join BaseCompensations as BaseCompensations
				on BaseCompensations.Employee = Records.Employee
				and BaseCompensations.BaseCompensation = Records.Compensation
				and BaseCompensations.DateStart &gt;= Records.DateStart
				and BaseCompensations.DateEnd &lt;= Records.DateEnd
				and BaseCompensations.Level = 3
				//
				// ExchangeRates
				//
				left join ExchangeRates as ExchangeRates
				on ExchangeRates.Currency = BaseCompensations.Currency
			union all
			select Compensations.Employee, Compensations.DateStart, Compensations.DateEnd,
				Compensations.Compensation, Compensations.Hours,
				case Compensations.Currency
					when BaseCompensations.Currency then Compensations.Result
					else Compensations.AccountingResult / isnull ( ExchangeRates.Rate, 1 ) * isnull ( ExchangeRates.Factor, 1 )
				end
			from Document.Payroll.Compensations as Compensations
				//
				// Base
				//
				join BaseCompensations as BaseCompensations
				on BaseCompensations.Employee = Compensations.Employee
				and BaseCompensations.BaseCompensation = Compensations.Compensation
				and BaseCompensations.DateStart &gt;= Compensations.DateStart
				and BaseCompensations.DateEnd &lt;= Compensations.DateEnd
				and BaseCompensations.Level = 3
				//
				// ExchangeRates
				//
				left join ExchangeRates as ExchangeRates
				on ExchangeRates.Currency = BaseCompensations.Currency
			where Compensations.Ref.Date between &amp;DateStart and &amp;DateEnd
			and Compensations.Ref.Posted
			) as Basis
		group by Basis.Employee, Basis.DateStart, Basis.DateEnd, Basis.Compensation
		) as Basis
	on Basis.Employee = Records.Employee
	and Basis.Compensation = Records.Compensation
	and Basis.DateStart = Records.DateStart
	and Basis.DateEnd = Records.DateEnd
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Records.Currency
where Records.Level = 3
;
// AllCompensations
select false as Edit, Records.Employee as Employee, Records.Department as Department, Records.Position as Position,
	Records.Expenses as Expenses, Records.Schedule as Schedule, Records.DateStart as DateStart, Records.DateEnd as DateEnd,
	Records.Compensation as Compensation, Records.Rate as Rate, Records.InHand as InHand, Records.Currency as Currency,
	Records.ScheduledHours as ScheduledHours, Records.ScheduledDays as ScheduledDays,
	Records.Hours as Hours, Records.Days as Days, Records.Account as Account,
	Records.Priority as Priority, Records.Level as Level,
	isnull ( ExchangeRates.Rate, 1 ) as ExchangeRate, isnull ( ExchangeRates.Factor, 1 ) as ExchangeFactor,
	Records.HourlyRate as HourlyRate, Records.Result as Result, 
	cast ( Records.Result * isnull ( ExchangeRates.Rate, 1 ) / isnull ( ExchangeRates.Factor, 1 ) as Number ( 15, 2 ) ) as AccountingResult,
	Records.DailyRate as DailyRate, Records.BaseAmount as BaseAmount, Records.BaseDays as BaseDays,
	Records.Bonuses as Bonuses, Records.BasePeriod as BasePeriod, Records.BaseHolidays as BaseHolidays,
	Records.Reference as Reference, Records.AnnualBonuses as AnnualBonuses, Records.QuarterlyBonuses as QuarterlyBonuses,
	Records.Holidays as Holidays, Records.BaseScheduledDays as BaseScheduledDays, Records.OnCompany as OnCompany
into AllCompensations
from (
	select Records.Employee as Employee, Records.Department as Department, Records.Position as Position,
		Records.Expenses as Expenses, Records.Schedule as Schedule, Records.DateStart as DateStart,
		Records.DateEnd as DateEnd, Records.Compensation as Compensation, Records.Rate as Rate, Records.InHand as InHand,
		Records.Currency as Currency, Records.ScheduledHours as ScheduledHours, Records.ScheduledDays as ScheduledDays,
		Records.Hours as Hours, Records.Days as Days, Records.Account as Account,
		Records.Priority as Priority, 0 as Level, Records.Result as Result, Records.HourlyRate as HourlyRate,
		Records.DailyRate as DailyRate, Records.BaseAmount as BaseAmount, Records.BaseDays as BaseDays,
		Records.Bonuses as Bonuses, Records.BasePeriod as BasePeriod, Records.BaseHolidays as BaseHolidays,
		Records.Reference as Reference, Records.AnnualBonuses as AnnualBonuses, Records.QuarterlyBonuses as QuarterlyBonuses,
		Records.Holidays as Holidays, Records.BaseScheduledDays as BaseScheduledDays, Records.OnCompany as OnCompany
	from Calculations0 as Records
	union all
	select Records.Employee, Records.Department, Records.Position, Records.Expenses, Records.Schedule, Records.DateStart,
		Records.DateEnd, Records.Compensation, Records.Rate, Records.InHand, Records.Currency, Records.ScheduledHours,
		Records.ScheduledDays, Records.Hours, Records.Days, Records.Account, Records.Priority, 1, Records.Result,
		Records.HourlyRate, 0, 0, 0, 0, 0, 0, undefined, Records.AnnualBonuses, Records.QuarterlyBonuses, Records.Holidays,
		Records.BaseScheduledDays, Records.OnCompany
	from Calculations1 as Records
	union all
	select Records.Employee, Records.Department, Records.Position, Records.Expenses, Records.Schedule, Records.DateStart,
		Records.DateEnd, Records.Compensation, Records.Rate, Records.InHand, Records.Currency, Records.ScheduledHours,
		Records.ScheduledDays, Records.Hours, Records.Days, Records.Account, Records.Priority, 2, Records.Result,
		Records.HourlyRate, 0, 0, 0, 0, 0, 0, undefined, Records.AnnualBonuses, Records.QuarterlyBonuses, Records.Holidays,
		Records.BaseScheduledDays, Records.OnCompany
	from Calculations2 as Records
	union all
	select Records.Employee, Records.Department, Records.Position, Records.Expenses, Records.Schedule, Records.DateStart,
		Records.DateEnd, Records.Compensation, Records.Rate, Records.InHand, Records.Currency, Records.ScheduledHours,
		Records.ScheduledDays, Records.Hours, Records.Days, Records.Account, Records.Priority, 3, Records.Result,
		Records.HourlyRate, 0, 0, 0, 0, 0, 0, undefined, Records.AnnualBonuses, Records.QuarterlyBonuses, Records.Holidays,
		Records.BaseScheduledDays, Records.OnCompany
	from Calculations3 as Records
	) as Records
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Records.Currency
union all
select true, Payroll.Employee, Payroll.Department, Payroll.Position, Payroll.Expenses, Payroll.Schedule,
	Payroll.DateStart, Payroll.DateEnd, Payroll.Compensation, Payroll.Rate, Payroll.InHand, Payroll.Currency,
	Payroll.ScheduledHours, Payroll.ScheduledDays, Payroll.Hours, Payroll.Days, Payroll.Account,
	case Payroll.Compensation.Method
	 	when value ( Enum.Calculations.MonthlyRate ) then 0
		when value ( Enum.Calculations.HourlyRate ) then 1
		when value ( Enum.Calculations.EveningHours ) then 2
		when value ( Enum.Calculations.NightHours ) then 3
		else 4
	end,
	Levels.Level, isnull ( ExchangeRates.Rate, 1 ), isnull ( ExchangeRates.Factor, 1 ),
	Payroll.HourlyRate, Payroll.Result, Payroll.AccountingResult, Payroll.DailyRate, Payroll.BaseAmount,
	Payroll.BaseDays, Payroll.Bonuses, Payroll.BasePeriod, Payroll.BaseHolidays, Payroll.Reference, 
	Payroll.BaseAnnualBonuses, Payroll.BaseQuarterlyBonuses, Payroll.Holidays, Payroll.BaseScheduledDays,
	Payroll.OnCompany
from Document.Payroll.Compensations as Payroll
	//
	// Levels
	//
	left join Levels as Levels
	on Levels.Compensation = Payroll.Compensation
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Payroll.Currency
where &amp;Calculating
and Payroll.Edit
{where Payroll.Ref = &amp;CalculatingPayroll and &amp;CalculatingPayroll &lt;&gt; value ( Document.Payroll.EmptyRef )}
union all
select Payroll.Edit, Payroll.Employee, Payroll.Department, Payroll.Position, Payroll.Expenses, Payroll.Schedule,
	Payroll.DateStart, Payroll.DateEnd, Payroll.Compensation, Payroll.Rate, Payroll.InHand, Payroll.Currency,
	Payroll.ScheduledHours, Payroll.ScheduledDays, Payroll.Hours, Payroll.Days, Payroll.Account,
	case Payroll.Compensation.Method
	 	when value ( Enum.Calculations.MonthlyRate ) then 0
		when value ( Enum.Calculations.HourlyRate ) then 1
		when value ( Enum.Calculations.EveningHours ) then 2
		when value ( Enum.Calculations.NightHours ) then 3
		else 4
	end,
	Levels.Level, isnull ( ExchangeRates.Rate, 1 ), isnull ( ExchangeRates.Factor, 1 ),
	Payroll.HourlyRate, Payroll.Result, Payroll.AccountingResult, Payroll.DailyRate, Payroll.BaseAmount,
	Payroll.BaseDays, Payroll.Bonuses, Payroll.BasePeriod, Payroll.BaseHolidays, Payroll.Reference,
	Payroll.BaseAnnualBonuses, Payroll.BaseQuarterlyBonuses, Payroll.Holidays, Payroll.BaseScheduledDays,
	Payroll.OnCompany
from Document.Payroll.Compensations as Payroll
	//
	// Levels
	//
	left join Levels as Levels
	on Levels.Compensation = Payroll.Compensation
	//
	// ExchangeRates
	//
	left join ExchangeRates as ExchangeRates
	on ExchangeRates.Currency = Payroll.Currency
where &amp;TaxesOnly
{where Payroll.Ref = &amp;CalculatingTaxesPayroll and &amp;CalculatingTaxesPayroll &lt;&gt; value ( Document.Payroll.EmptyRef )}
;
// ActualCompensations
select Compensations.Edit as Edit, Compensations.Employee as Employee, Compensations.Employee.Individual as Individual,
	Compensations.Department as Department, Compensations.Position as Position, Compensations.Expenses as Expenses,
	Compensations.Schedule as Schedule, Compensations.DateStart as DateStart, Compensations.DateEnd as DateEnd,
	Compensations.Compensation as Compensation, Compensations.Rate as Rate, Compensations.InHand as InHand,
	Compensations.Currency as Currency, Compensations.ScheduledHours as ScheduledHours,
	Compensations.ScheduledDays as ScheduledDays, Compensations.Hours as Hours, Compensations.Days as Days,
	Compensations.Account as Account, Compensations.Priority as Priority, Compensations.Level as Level,
	Compensations.ExchangeRate as ExchangeRate, Compensations.ExchangeFactor as ExchangeFactor,
	Compensations.HourlyRate as HourlyRate, Compensations.Result as Result, Compensations.AccountingResult as AccountingResult,
	Compensations.DailyRate as DailyRate, Compensations.BaseAmount as BaseAmount, Compensations.BaseDays as BaseDays,
	Compensations.Bonuses as Bonuses, Compensations.BasePeriod as BasePeriod, Compensations.BaseHolidays as BaseHolidays,
	Compensations.Reference as Reference, Compensations.AnnualBonuses as BaseAnnualBonuses,
	Compensations.QuarterlyBonuses as BaseQuarterlyBonuses, Compensations.Holidays as Holidays,
	Compensations.BaseScheduledDays as BaseScheduledDays, Compensations.OnCompany as OnCompany, recordautonumber () as Key
into ActualCompensations
from AllCompensations as Compensations
	//
	// Exclude manually changed records
	//
	left join AllCompensations as Changes
	on Changes.Edit
	and Changes.Employee = Compensations.Employee
	and Changes.Compensation = Compensations.Compensation
	and Changes.DateStart = Compensations.DateStart
	and Changes.DateEnd = Compensations.DateEnd
where Compensations.Edit
or ( Changes.Edit is null
	and (
		Compensations.Result &lt;&gt; 0
		or Compensations.AccountingResult &lt;&gt; 0
		or Compensations.Days &lt;&gt; 0
		or Compensations.Hours &lt;&gt; 0
	)
)
;
// Blank for Reversed Salary
select null as Key, 0 as Result
into ReversedSalary
where false
;
// Final selection: Base
select Base.Document as Document, Base.Employee as Employee, Base.Bonuses as Bonuses,
	Base.Days as Days, Schedules.Days as ScheduledDays, Base.Period as Period,
	Base.Amount as Amount
{select Document, Employee, Bonuses, Days, ScheduledDays, Period, Amount}
from (
	select Compensations.Ref as Document, Compensations.Employee as Employee,
		beginofperiod ( Compensations.DateStart, month ) as Period, Compensations.Schedule as Schedule,
		sum (
			case when Compensations.Method in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent ),
						value ( Enum.Calculations.Annual ),
						value ( Enum.Calculations.Quarterly )
					) then Compensations.Amount
				else 0
			end
		) as Bonuses,
		sum (
			case when Compensations.Method in (
						value ( Enum.Calculations.MonthlyRate ),
						value ( Enum.Calculations.HourlyRate )
					) then Compensations.Days
				else 0
			end
		) as Days,
		sum (
			case when Compensations.Method not in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent ),
						value ( Enum.Calculations.Annual ),
						value ( Enum.Calculations.Quarterly )
					) then Compensations.Amount
				else 0
			end
		) as Amount
	from PreviousCompensationsForSickLeaves as Compensations
		//
		// BaseCompensations
		//
		join ChartOfCalculationTypes.Compensations.BaseCalculationTypes as BaseCompensations
		on BaseCompensations.CalculationType = Compensations.Compensation
		//
		// SickLeaves
		//
		join (
			select SickLeaves.Ref as Ref, SickLeaves.Compensation as Compensation
			from SickLeaves as SickLeaves
			group by SickLeaves.Ref, SickLeaves.Compensation
		) as SickLeaves 
		on SickLeaves.Ref = Compensations.Ref
		and SickLeaves.Compensation = BaseCompensations.Ref
	group by Compensations.Ref, Compensations.Employee,
		beginofperiod ( Compensations.DateStart, month ),
		Compensations.Schedule
	union all
	select Compensations.Ref as Document, Compensations.Employee as Employee,
		beginofperiod ( Compensations.DateStart, month ) as Period, Compensations.Schedule as Schedule,
		sum (
			case when Compensations.Method in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent ),
						value ( Enum.Calculations.Annual ),
						value ( Enum.Calculations.Quarterly )
					) then Compensations.Amount
				else 0
			end
		) as Bonuses,
		sum (
			case when Compensations.Method in (
						value ( Enum.Calculations.MonthlyRate ),
						value ( Enum.Calculations.HourlyRate )
					) then Compensations.Days
				else 0
			end
		) as Days,
		sum (
			case when Compensations.Method not in (
						value ( Enum.Calculations.FixedAmount ),
						value ( Enum.Calculations.Percent ),
						value ( Enum.Calculations.Annual ),
						value ( Enum.Calculations.Quarterly )
					) then Compensations.Amount
				else 0
			end
		) as Amount
	from PreviousCompensationsForVacations as Compensations
		//
		// BaseCompensations
		//
		join ChartOfCalculationTypes.Compensations.BaseCalculationTypes as BaseCompensations
		on BaseCompensations.CalculationType = Compensations.Compensation
		//
		// Vacations
		//
		join (
			select Vacations.Ref as Ref, Vacations.Employee as Employee,
				Vacations.Compensation as Compensation
			from VacationsToCalculate as Vacations
			group by Vacations.Ref, Vacations.Employee, Vacations.Compensation
		) as Vacations 
		on Vacations.Ref = Compensations.Ref
		and Vacations.Employee = Compensations.Employee
		and Vacations.Compensation = BaseCompensations.Ref
	group by Compensations.Ref, Compensations.Employee,
		beginofperiod ( Compensations.DateStart, month ),
		Compensations.Schedule
	) as Base
	//
	// Schedules
	//
	join (
		select Schedules.Ref as Ref, Schedules.Employee as Employee,
			Schedules.Schedule as Schedule, Schedules.Period as Period, 
			Schedules.Days as Days
		from PreviousSchedulesForSickLeaves as Schedules
		union all
		select Schedules.Ref, Schedules.Employee as Employee,
			Schedules.Schedule, Schedules.Period, Schedules.Days
		from PreviousSchedulesForVacations as Schedules
	) as Schedules
	on Schedules.Ref = Base.Document
	and Schedules.Employee = Base.Employee
	and Schedules.Schedule = Base.Schedule
	and Schedules.Period = Base.Period
;
// Just one record to see if reverse calculation is needed
select top 1 *
{select Edit, Employee.*, Individual.*, Department.*, Position.*, Expenses.*, Schedule.*, DateStart, DateEnd, Result, AccountingResult,
	Compensation.*, Rate, Currency.*, ScheduledHours, ScheduledDays, Hours, Days, Account.*, Reference.*,
	ExchangeRate, ExchangeFactor, Priority, Level, HourlyRate, DailyRate, BaseAmount, BaseDays, Bonuses, BasePeriod, BaseHolidays, OnCompany}
from ActualCompensations
	//
	// Will force to create a ReverseSalary table
	//
	left join ReversedSalary
	on false
where InHand
</query>
		<autoFillFields>false</autoFillFields>
		<useQueryGroupIfPossible>false</useQueryGroupIfPossible>
	</dataSet>
	<dataSet xsi:type="DataSetQuery">
		<name>InHand</name>
		<field xsi:type="DataSetFieldField">
			<dataPath>Result</dataPath>
			<field>Result</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Result</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Key</dataPath>
			<field>Key</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Key</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Company</dataPath>
			<field>Company</field>
		</field>
		<dataSource>DataSource1</dataSource>
		<query>// ActualCompensations
select Compensations.Employee as Employee, Compensations.Individual as Individual,
	Compensations.Compensation as Compensation, Compensations.InHand as InHand,
	sum ( Compensations.AccountingResult ) as Amount
into CompensationsInHand
from ActualCompensations as Compensations
where not Compensations.Edit
and Compensations.Employee in (
	select distinct Compensations.Employee
	from ActualCompensations as Compensations
	where Compensations.InHand
)
group by Compensations.Employee, Compensations.Individual, Compensations.Compensation, Compensations.InHand
;
// SelectedEmployees
select distinct Compensations.Employee as Employee
into SelectedEmployees
from CompensationsInHand as Compensations
index by Employee
;
// PaymentCalendar
select Period as Period
into PaymentCalendar
from (
	select &amp;YearStart as Period
	union all
	select dateadd ( &amp;YearStart, month, 1 )
	union all
	select dateadd ( &amp;YearStart, month, 2 )
	union all
	select dateadd ( &amp;YearStart, month, 3 )
	union all
	select dateadd ( &amp;YearStart, month, 4 )
	union all
	select dateadd ( &amp;YearStart, month, 5 )
	union all
	select dateadd ( &amp;YearStart, month, 6 )
	union all
	select dateadd ( &amp;YearStart, month, 7 )
	union all
	select dateadd ( &amp;YearStart, month, 8 )
	union all
	select dateadd ( &amp;YearStart, month, 9 )
	union all
	select dateadd ( &amp;YearStart, month, 10 )
	union all
	select dateadd ( &amp;YearStart, month, 11 )
	) as Calendar
where Calendar.Period between &amp;YearStart and &amp;PaymentDate
index by Period
;
// DeductionRates
select &amp;YearStart as Period, Deductions.Deduction as Deduction, Deductions.Rate as Rate
into DeductionRates
from InformationRegister.DeductionRates.SliceLast ( &amp;YearStart ) as Deductions
union all
select Deductions.Period, Deductions.Deduction, Deductions.Rate
from InformationRegister.DeductionRates as Deductions
where Deductions.Period &gt; &amp;YearStart and Deductions.Period &lt;= &amp;PaymentDate
index by Period
;
// DeductionsList
select Calendar.Period as Period, Deductions.Deduction as Deduction, Deductions.Rate as Rate
into DeductionsList
from PaymentCalendar as Calendar
	//
	// DeductionPeriods
	//
	join (
		select Calendar.Period as Period, Deductions.Deduction as Deduction, max ( Deductions.Period ) as DeductionPeriod
		from PaymentCalendar as Calendar
			//
			// Deductions
			//
			left join DeductionRates as Deductions
			on Deductions.Period &lt;= Calendar.Period
		group by Calendar.Period, Deductions.Deduction
	) as DeductionPeriods
	on DeductionPeriods.Period = Calendar.Period
	//
	// DeductionRate
	//
	join DeductionRates as Deductions
	on Deductions.Deduction = DeductionPeriods.Deduction
	and Deductions.Period = DeductionPeriods.DeductionPeriod
index by Period, Deduction
;
// EmployeeDeductions
select &amp;YearStart as Period, true as Use, Deductions.Employee.Individual as Employee, Deductions.Deduction as Deduction
into EmployeeDeductions
from InformationRegister.Deductions.SliceLast ( &amp;YearStart, Employee in ( select Employee from SelectedEmployees ) ) as Deductions
where Deductions.Use
union all
select Deductions.Period, Deductions.Use, Deductions.Employee.Individual, Deductions.Deduction
from InformationRegister.Deductions as Deductions
where Employee.Individual in ( select distinct Individual from CompensationsInHand )
and Deductions.Period &gt; &amp;YearStart and Deductions.Period &lt;= &amp;PaymentDate
index by Period, Employee
;
// EmployeeDeductionPeriods
select Calendar.Period as Period, Deductions.Employee as Employee, Deductions.Deduction as Deduction,
	max ( Deductions.Period ) as DeductionPeriod
into EmployeeDeductionPeriods
from PaymentCalendar as Calendar
	//
	// Deductions
	//
	left join EmployeeDeductions as Deductions
	on Deductions.Period &lt;= Calendar.Period
group by Calendar.Period, Deductions.Employee, Deductions.Deduction
index by Period, Employee
;
// Deductions
select Deductions.Employee as Employee, sum ( Deductions.Amount ) as Amount
into Deductions
from (
	select Deductions.Employee as Employee, case when Deductions.Use then DeductionsList.Rate / 12 else 0 end as Amount
	from PaymentCalendar as Calendar
		//
		// DeductionPeriods
		//
		join EmployeeDeductionPeriods as DeductionPeriods
		on DeductionPeriods.Period = Calendar.Period
		//
		// Deductions
		//
		join EmployeeDeductions as Deductions
		on Deductions.Period = DeductionPeriods.DeductionPeriod
		and Deductions.Employee = DeductionPeriods.Employee
		and Deductions.Deduction = DeductionPeriods.Deduction
		//
		// DeductionsList
		//
		join DeductionsList as DeductionsList
		on DeductionsList.Period = Calendar.Period
		and DeductionsList.Deduction = Deductions.Deduction
	union all
	select Unused.Employee.Individual, Unused.Amount
	from InformationRegister.UnusedDeductions as Unused
	where Unused.Employee in ( select Employee from SelectedEmployees )
	and Unused.Year = &amp;YearStart
	union all
	select AppliedDeductions.Employee, - AppliedDeductions.Deductions
	from Document.PayEmployees.Taxes as AppliedDeductions
	where AppliedDeductions.Ref.Date between &amp;YearStart and &amp;PaymentDate
	and AppliedDeductions.Ref.Posted
	and AppliedDeductions.Deductions &lt;&gt; 0
	and AppliedDeductions.Employee in ( select distinct Individual from CompensationsInHand )
	{where AppliedDeductions.Ref.Company.* as Company}
	union all
	select AppliedDeductions.Individual, - AppliedDeductions.Deductions
	from Document.PayrollBalances.Employees as AppliedDeductions
	where AppliedDeductions.Ref.Date between &amp;YearStart and &amp;PaymentDate
	and AppliedDeductions.Ref.Posted
	and AppliedDeductions.Deductions &lt;&gt; 0
	and AppliedDeductions.Employee in ( select Employee from SelectedEmployees )
	{where AppliedDeductions.Ref.Company.* as Company}
	) as Deductions
group by Deductions.Employee
having sum ( Deductions.Amount ) &gt; 0
index by Employee
;
// TaxRates
select Rates.Tax as Tax, Rates.Rate as Rate
into TaxRates
from InformationRegister.PayrollTaxes.SliceLast ( &amp;DateEnd,
	Tax.Net
	or Tax.Method in (
		value ( Enum.Calculations.MedicalInsurance ),
		value ( Enum.Calculations.IncomeTax ) ) ) as Rates
where Rates.Use
;
// MedicalGrossSalary
select Compensations.Individual as Employee, Compensations.Compensation as Compensation,
	Compensations.Amount / 100 * Rates.Rate as Result
into MedicalGrossSalary
from CompensationsInHand as Compensations
	//
	// Taxes
	//
	join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as Taxes
	on Taxes.CalculationType = Compensations.Compensation
	and not Taxes.Ref.DeletionMark
	and Taxes.Ref.Method = value ( Enum.Calculations.MedicalInsurance )
	//
	// Rates
	//
	join TaxRates as Rates
	on Rates.Tax = Taxes.Ref
where not Compensations.InHand
;
// IncomeTaxCompensations
select Base.Employee as Employee, Base.Compensation as Compensation,
	sum ( Base.Amount ) as Amount, max ( Rates.Rate ) as Rate, recordautonumber () as Key
into IncomeTaxCompensations
from (
	select Base.Employee as Employee, Base.Compensation as Compensation, sum ( Base.Amount ) as Amount
	from (
		select Compensations.Individual as Employee, Compensations.Compensation as Compensation, Compensations.Amount as Amount
		from CompensationsInHand as Compensations
		where not Compensations.InHand
		union all
		select Medical.Employee, Medical.Compensation, - Medical.Result
		from MedicalGrossSalary as Medical
	) as Base
	group by Base.Employee, Base.Compensation
) as Base
	//
	// Taxes
	//
	join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as Taxes
	on Taxes.CalculationType = Base.Compensation
	and not Taxes.Ref.DeletionMark
	and Taxes.Ref.Method = value ( Enum.Calculations.IncomeTax )
	//
	// Rates
	//
	join TaxRates as Rates
	on Rates.Tax = Taxes.Ref
group by Base.Employee, Base.Compensation
;
// BiggestCompensations
select Base.Employee as Employee, max ( Base.Key ) as Key
into BiggestCompensations
from IncomeTaxCompensations as Base
	//
	// Only max
	//
	join (
		select BiggestBase.Employee as Employee, max ( BiggestBase.Amount ) as Amount
		from IncomeTaxCompensations as BiggestBase
		group by BiggestBase.Employee
	) as BiggestBase
	on BiggestBase.Employee = Base.Employee
group by Base.Employee
;
// IncomeTaxGrossSalary
select Compensations.Employee as Employee, Compensations.Compensation as Compensation,
	( Compensations.Amount - isnull ( Deductions.Amount, 0 ) ) / 100 * Compensations.Rate as Result
into IncomeTaxGrossSalary
from IncomeTaxCompensations as Compensations
	//
	// Filter by biggest
	//
	left join BiggestCompensations as BiggestCompensations
	on BiggestCompensations.Key = Compensations.Key
	//
	// Deductions
	//
	left join Deductions as Deductions
	on Deductions.Employee = Compensations.Employee
	and BiggestCompensations.Key is not null
;
// OtherTaxesGrossSalary
select Base.Employee as Employee, Base.Compensation as Compensation,
	sum ( Base.Amount / 100 * Rates.Rate ) as Result
into OtherTaxesGrossSalary
from (                                                                                         
	select Base.Employee as Employee, Base.Compensation as Compensation, sum ( Base.Amount ) as Amount
	from (
		select Compensations.Individual as Employee, Compensations.Compensation as Compensation, Compensations.Amount as Amount
		from CompensationsInHand as Compensations
		where not Compensations.InHand
		union all
		select Medical.Employee, Medical.Compensation, - Medical.Result
		from MedicalGrossSalary as Medical
		union all
		select IncomeTax.Employee, IncomeTax.Compensation, - IncomeTax.Result
		from IncomeTaxGrossSalary as IncomeTax
	) as Base
	group by Base.Employee, Base.Compensation
) as Base
	//
	// Taxes
	//
	join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as Taxes
	on Taxes.CalculationType = Base.Compensation
	and not Taxes.Ref.DeletionMark
	and not Taxes.Ref.Method in ( value ( Enum.Calculations.Percent ), value ( Enum.Calculations.FixedAmount ) )
	and Taxes.Ref.Net
	//
	// Rates
	//
	join TaxRates as Rates
	on Rates.Tax = Taxes.Ref
group by Base.Employee, Base.Compensation
;
// NetWithoutDeductions
select NetSalary.Individual as Individual, NetSalary.Compensation as Compensation, sum ( NetSalary.Amount ) as p,
	sum ( isnull ( OtherTaxesRates.Rate, 0 ) ) / 100 as k, sum ( isnull ( OtherTaxesAmountRates.Rate, 0 ) ) as s,
	sum ( isnull ( IncomeTaxRates.Rate, 0 ) ) / 100 as i, sum ( isnull ( MedicalTaxRates.Rate, 0 ) ) / 100 as m,
	recordautonumber () as Row
into NetWithoutDeductions
from (
	select Compensations.Individual as Individual, Compensations.Compensation as Compensation, sum ( Compensations.Amount ) as Amount
	from (
		select Compensations.Individual as Individual, Compensations.Compensation as Compensation, Compensations.Amount as Amount
		from CompensationsInHand as Compensations
		union all
		select Medical.Employee, Medical.Compensation, - Medical.Result
		from MedicalGrossSalary as Medical
		union all
		select IncomeTax.Employee, IncomeTax.Compensation, - IncomeTax.Result
		from IncomeTaxGrossSalary as IncomeTax
		union all
		select OtherTaxes.Employee, OtherTaxes.Compensation, - OtherTaxes.Result
		from OtherTaxesGrossSalary as OtherTaxes
	) as Compensations
	group by Compensations.Individual, Compensations.Compensation
) as NetSalary
	//
	// OtherTaxesPercent
	//
	left join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as OtherTaxes
	on OtherTaxes.CalculationType = NetSalary.Compensation
	and not OtherTaxes.Ref.DeletionMark
	and OtherTaxes.Ref.Method = value ( Enum.Calculations.Percent )
	and OtherTaxes.Ref.Net
	//
	// OtherTaxesRates
	//
	left join TaxRates as OtherTaxesRates
	on OtherTaxesRates.Tax = OtherTaxes.Ref
	//
	// OtherTaxesAmount
	//
	left join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as OtherTaxesAmount
	on OtherTaxesAmount.CalculationType = NetSalary.Compensation
	and not OtherTaxesAmount.Ref.DeletionMark
	and OtherTaxesAmount.Ref.Method = value ( Enum.Calculations.FixedAmount )
	and OtherTaxesAmount.Ref.Net
	//
	// OtherTaxesAmountRates
	//
	left join TaxRates as OtherTaxesAmountRates
	on OtherTaxesAmountRates.Tax = OtherTaxesAmount.Ref
	// 
	// IncomeTax
	//                                                              
	left join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as IncomeTax
	on IncomeTax.CalculationType = NetSalary.Compensation
	and not IncomeTax.Ref.DeletionMark
	and IncomeTax.Ref.Method = value ( Enum.Calculations.IncomeTax )
	// 
	// IncomeTaxRates
	//
	left join TaxRates as IncomeTaxRates
	on IncomeTaxRates.Tax = IncomeTax.Ref
	// 
	// Medical
	//                                                              
	left join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as MedicalTax
	on MedicalTax.CalculationType = NetSalary.Compensation
	and not MedicalTax.Ref.DeletionMark
	and MedicalTax.Ref.Method = value ( Enum.Calculations.MedicalInsurance )
	// 
	// MedicalTaxRates
	//
	left join TaxRates as MedicalTaxRates
	on MedicalTaxRates.Tax = MedicalTax.Ref
group by NetSalary.Individual, NetSalary.Compensation
;
// NetSalary
select NetSalary.Individual as Individual, NetSalary.Compensation as Compensation, NetSalary.p as p,
	NetSalary.k as k, NetSalary.s as s, NetSalary.i as i, NetSalary.m as m,
	isnull ( Deductions.Amount, 0 ) as d
into NetSalary
from NetWithoutDeductions as NetSalary
	//
	// Max Compensation
	//
	left join (
		select min ( Salary.Row ) as Row
		from NetWithoutDeductions as Salary
			//
			// Max amount
			//
			join (
				select Salary.Individual as Individual, max ( Salary.p ) as p
				from NetWithoutDeductions as Salary
				where Salary.i &lt;&gt; 0
				group by Salary.Individual
			) MaxAmount
			on MaxAmount.Individual = Salary.Individual
			and MaxAmount.p = Salary.p
		where Salary.i &lt;&gt; 0
		group by Salary.Individual
	) as MaxCompensations
	on MaxCompensations.Row = NetSalary.Row
	//
	// Deductions
	//
	left join Deductions as Deductions
	on Deductions.Employee = NetSalary.Individual
	and MaxCompensations.Row = NetSalary.Row
;
// GrossSalary
select NetSalary.Individual as Individual, NetSalary.Compensation as Compensation,
	case when ( -k + 1 ) = 0 or ( -i + 1 ) = 0 or ( -m + 1 ) = 0 then 0
	else
		// n = p; // p = initial net amount
		// n = n + s; // s = tax (fixed amount) from net amount
		// n = Round ( n / ( -k + 1 ), 2 ); // k = tax (percent) from net amount
		// n = Round ( ( n - i * d ) / ( -i + 1 ), 2 ); // i = income tax, d = deductions
		// n = Round ( n / ( -m + 1 ), 2 ); // m = medicine (percent)
		cast ( ( cast ( ( ( cast ( ( p + s ) / ( -k + 1 ) as Number ( 15, 2 ) ) ) - i * d ) / ( -i + 1 ) as Number ( 15, 2 ) ) ) / ( -m + 1 ) as Number ( 15, 2 ) )
	end as Amount
into GrossSalary
from NetSalary as NetSalary
;
// DistributionBase
select Compensations.Individual as Individual, Compensations.Compensation as Compensation,
	sum ( Compensations.Amount ) as Amount
into DistributionBase
from CompensationsInHand as Compensations
group by Compensations.Individual, Compensations.Compensation
;
// Distributed
select Compensations.Key as Key, Compensations.Employee as Employee, Compensations.Individual as Individual,
	Compensations.Compensation as Compensation,
	case when Compensations.InHand then
		cast ( Compensations.AccountingResult * ( GrossSalary.Amount / DistributionBase.Amount ) as Number ( 15, 2 ) )
	else Compensations.AccountingResult
	end as AccountingResult
into Distributed
from ActualCompensations as Compensations
	//
	// DistributionBase
	//
	join DistributionBase as DistributionBase
	on DistributionBase.Individual = Compensations.Individual
	and DistributionBase.Compensation = Compensations.Compensation
	//
	// GrossSalary
	//
	join GrossSalary as GrossSalary
	on GrossSalary.Individual = Compensations.Individual
	and GrossSalary.Compensation = Compensations.Compensation
where not Compensations.Edit
;
drop ReversedSalary
;
// ReversedSalary
select ReversedSalary.Key as Key, sum ( ReversedSalary.Result ) as Result
into ReversedSalary
from (
	select Distributed.Key as Key, Distributed.AccountingResult as Result
	from Distributed as Distributed
	union all
	select Compensations.Key, Discrepancy.Amount
	from (                                                        	
		select Discrepancy.Individual as Individual, Discrepancy.Compensation as Compensation, sum ( Discrepancy.Amount ) as Amount
		from (                                          	
			select GrossSalary.Individual as Individual, GrossSalary.Compensation as Compensation, GrossSalary.Amount as Amount
			from GrossSalary as GrossSalary
			union all
			select Distributed.Individual, Distributed.Compensation, - sum ( Distributed.AccountingResult )
			from Distributed as Distributed
			group by Distributed.Individual, Distributed.Compensation
		) as Discrepancy
		group by Discrepancy.Individual, Discrepancy.Compensation
		having sum ( Discrepancy.Amount ) &lt;&gt; 0
	) as Discrepancy
		//
		// Put difference to biggest compensation
		//
		join (
			select Compensations.Key as Key, Compensations.Individual as Individual, Compensations.Compensation as Compensation
			from ActualCompensations as Compensations
				//
				// Filter by max row
				//
				join (
					select Compensations.Individual as Individual, Compensations.Compensation as Compensation, max ( Compensations.Key ) as Key
					from ActualCompensations as Compensations
						//
						// MaxCompensations
						//
						join (
							select Compensations.Individual as Individual, Compensations.Compensation as Compensation,
								max ( Compensations.AccountingResult ) as Amount
							from ActualCompensations as Compensations
							where Compensations.InHand
							and not Compensations.Edit
							group by Compensations.Individual, Compensations.Compensation
						) as MaxCompensations
						on MaxCompensations.Individual = Compensations.Individual
						and MaxCompensations.Compensation = Compensations.Compensation
						and MaxCompensations.Amount = Compensations.AccountingResult
					where not Compensations.Edit
					group by Compensations.Individual, Compensations.Compensation
				) as MaxCompensations
				on MaxCompensations.Key = Compensations.Key
			where not Compensations.Edit
		) as Compensations
		on Compensations.Individual = Discrepancy.Individual
		and Compensations.Compensation = Discrepancy.Compensation
) as ReversedSalary
group by ReversedSalary.Key
;
// Force DCS to proceed the query
select top 1 ReversedSalary.Key as Key, ReversedSalary.Result as Result
{select Key, Result}
from ReversedSalary as ReversedSalary
where false
</query>
		<autoFillFields>false</autoFillFields>
		<useQueryGroupIfPossible>false</useQueryGroupIfPossible>
	</dataSet>
	<dataSet xsi:type="DataSetQuery">
		<name>Result</name>
		<field xsi:type="DataSetFieldField">
			<dataPath>BaseHolidays</dataPath>
			<field>BaseHolidays</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base holidays</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Level</dataPath>
			<field>Level</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Level</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Rate</dataPath>
			<field>Rate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>DateEnd</dataPath>
			<field>DateEnd</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Date end</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Department</dataPath>
			<field>Department</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Department</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BasePeriod</dataPath>
			<field>BasePeriod</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base period</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ScheduledDays</dataPath>
			<field>ScheduledDays</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Scheduled days</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Compensation</dataPath>
			<field>Compensation</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Compensation</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ExchangeFactor</dataPath>
			<field>ExchangeFactor</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Exchange factor</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Expenses</dataPath>
			<field>Expenses</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Expenses</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Schedule</dataPath>
			<field>Schedule</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Schedule</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Position</dataPath>
			<field>Position</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Position</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>AccountingResult</dataPath>
			<field>AccountingResult</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Accounting result</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Account</dataPath>
			<field>Account</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Account</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Result</dataPath>
			<field>Result</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Result</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Employee</dataPath>
			<field>Employee</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Employee</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>DateStart</dataPath>
			<field>DateStart</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Date start</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Edit</dataPath>
			<field>Edit</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Edit</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>HourlyRate</dataPath>
			<field>HourlyRate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Hourly rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Currency</dataPath>
			<field>Currency</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Currency</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ScheduledHours</dataPath>
			<field>ScheduledHours</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Scheduled hours</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Hours</dataPath>
			<field>Hours</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Hours</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>ExchangeRate</dataPath>
			<field>ExchangeRate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Exchange rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Days</dataPath>
			<field>Days</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Days</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Reference</dataPath>
			<field>Reference</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Reference</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Priority</dataPath>
			<field>Priority</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Priority</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>DailyRate</dataPath>
			<field>DailyRate</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Daily rate</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BaseAmount</dataPath>
			<field>BaseAmount</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base amount</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Individual</dataPath>
			<field>Individual</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Individual</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>BaseDays</dataPath>
			<field>BaseDays</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Base days</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>Bonuses</dataPath>
			<field>Bonuses</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>Bonuses</v8:content>
				</v8:item>
			</title>
		</field>
		<field xsi:type="DataSetFieldField">
			<dataPath>OnCompany</dataPath>
			<field>OnCompany</field>
			<title xsi:type="v8:LocalStringType">
				<v8:item>
					<v8:lang>en</v8:lang>
					<v8:content>On company</v8:content>
				</v8:item>
			</title>
		</field>
		<dataSource>DataSource1</dataSource>
		<query>// Final Payments
select Compensations.Edit as Edit, Compensations.Employee as Employee, Compensations.Individual as Individual,
	Compensations.Department as Department, Compensations.Position as Position, Compensations.Expenses as Expenses,
	Compensations.Schedule as Schedule, Compensations.DateStart as DateStart, Compensations.DateEnd as DateEnd,
	Compensations.Compensation as Compensation, Compensations.Rate as Rate, Compensations.InHand as InHand,
	Compensations.Currency as Currency, Compensations.ScheduledHours as ScheduledHours,
	Compensations.ScheduledDays as ScheduledDays, Compensations.Hours as Hours, Compensations.Days as Days,
	Compensations.Account as Account, Compensations.Priority as Priority, Compensations.Level as Level,
	Compensations.ExchangeRate as ExchangeRate, Compensations.ExchangeFactor as ExchangeFactor, Compensations.HourlyRate as HourlyRate,
	Compensations.DailyRate as DailyRate, Compensations.BaseAmount as BaseAmount, Compensations.BaseDays as BaseDays,
	Compensations.Bonuses as Bonuses, Compensations.BasePeriod as BasePeriod, Compensations.BaseHolidays as BaseHolidays,
	Compensations.Reference as Reference, Compensations.BaseAnnualBonuses as BaseAnnualBonuses,
	Compensations.BaseQuarterlyBonuses as BaseQuarterlyBonuses, Compensations.Holidays as Holidays,
	Compensations.BaseScheduledDays as BaseScheduledDays, Compensations.OnCompany as OnCompany,
	case
		when Reversed.Key is null then Compensations.Result
		else Reversed.Result / Compensations.ExchangeRate * Compensations.ExchangeFactor
	end as Result,
	isnull ( Reversed.Result, Compensations.AccountingResult ) as AccountingResult
into FinalPayments
from ActualCompensations as Compensations
	//
	// ReversedSalary
	//
	left join ReversedSalary as Reversed
	on Reversed.Key = Compensations.Key
;
// Final selection: Taxes
select Taxes.Edit as Edit, Taxes.Employee as Employee, Taxes.Employee.Individual as Individual,
	Taxes.Department as Department, Taxes.Expenses as Expenses, Taxes.Tax as Tax,
	Taxes.Account as Account, Taxes.Base as Base, Taxes.Result as Result,
	Taxes.DateStart as DateStart, Taxes.DateEnd as DateEnd, Taxes.Tax.Method as Method
from (
	select false as Edit, Based.Employee as Employee, Based.Department as Department,
		Based.Expenses as Expenses, Based.Tax as Tax, Based.Account as Account, Based.Amount as Base,
		Based.DateStart as DateStart, Based.DateEnd as DateEnd,
		case Rates.Tax.Method
			when value ( Enum.Calculations.FixedAmount ) then Rates.Rate
			else Based.Amount / 100 * Rates.Rate
		end as Result
	from (
		select Compensations.Employee as Employee, Compensations.Department as Department, Compensations.Expenses as Expenses,
			Compensations.DateStart as DateStart, Compensations.DateEnd as DateEnd,
			Taxes.Ref as Tax, Taxes.Ref.Account as Account, sum ( Compensations.AccountingResult ) as Amount
		from FinalPayments as Compensations
			//
			// Taxes
			//
			join ChartOfcalculationTypes.Taxes.BaseCalculationTypes as Taxes
			on Taxes.CalculationType = Compensations.Compensation
			and not Taxes.Ref.Method in (
				value ( Enum.Calculations.IncomeTax ),
				value ( Enum.Calculations.MedicalInsurance )
				)
			and not Taxes.Ref.Net
			and not Taxes.Ref.DeletionMark
		group by Compensations.Employee, Compensations.Department, Compensations.Expenses, Compensations.DateStart,
			Compensations.DateEnd, Taxes.Ref
		) as Based
		//
		// Rates
		//
		left join InformationRegister.PayrollTaxes.SliceLast ( &amp;DateEnd ) as Rates
		on Rates.Tax = Based.Tax
		and Rates.Use
		//
		// Exclude modified records
		//
		left join Document.Payroll.Taxes as Payroll
		on Payroll.Ref = &amp;Ref
		and Payroll.Employee = Based.Employee
		and Payroll.Tax = Based.Tax
		and Payroll.DateStart = Based.DateStart
		and Payroll.DateEnd = Based.DateEnd
		and Payroll.Edit
	where Payroll.Ref is null
	union all
	select true, Payroll.Employee, Payroll.Department, Payroll.Expenses, Payroll.Tax, Payroll.Account,
		Payroll.Base, Payroll.DateStart, Payroll.DateEnd, Payroll.Result
	from Document.Payroll.Taxes as Payroll
	where Payroll.Ref = &amp;Ref
	and Payroll.Edit ) as Taxes
order by Taxes.Employee.Description, Employee.Code,
	case Taxes.Tax.Method
		when value ( Enum.Calculations.SocialInsurance ) then 0
		else 1
	end
;
// Final selection: Compensations
select Compensations.Edit as Edit, Compensations.Employee as Employee, Compensations.Individual as Individual,
	Compensations.Department as Department, Compensations.Position as Position, Compensations.Expenses as Expenses,
	Compensations.Schedule as Schedule, Compensations.DateStart as DateStart, Compensations.DateEnd as DateEnd,
	Compensations.Compensation as Compensation, Compensations.Rate as Rate, Compensations.InHand as InHand,
	Compensations.Currency as Currency, Compensations.ScheduledHours as ScheduledHours,
	Compensations.ScheduledDays as ScheduledDays, Compensations.Hours as Hours, Compensations.Days as Days,
	Compensations.Account as Account, Compensations.Priority as Priority, Compensations.Level as Level,
	Compensations.ExchangeRate as ExchangeRate, Compensations.ExchangeFactor as ExchangeFactor, Compensations.HourlyRate as HourlyRate,
	Compensations.DailyRate as DailyRate, Compensations.BaseAmount as BaseAmount, Compensations.BaseDays as BaseDays,
	Compensations.Bonuses as Bonuses, Compensations.BasePeriod as BasePeriod, Compensations.BaseHolidays as BaseHolidays,
	Compensations.Reference as Reference, Compensations.BaseAnnualBonuses as BaseAnnualBonuses,
	Compensations.BaseQuarterlyBonuses as BaseQuarterlyBonuses, Compensations.Holidays as Holidays,
	Compensations.BaseScheduledDays as BaseScheduledDays, Compensations.Result as Result, Compensations.AccountingResult as AccountingResult,
	Compensations.OnCompany as OnCompany
{select Edit, Employee.*, Individual.*, Department.*, Position.*, Expenses.*, Schedule.*, DateStart, DateEnd, Result, AccountingResult,
	Compensation.*, Rate, Currency.*, ScheduledHours, ScheduledDays, Hours, Days, Account.*, Reference.*,
	ExchangeRate, ExchangeFactor, Priority, Level, HourlyRate, DailyRate, BaseAmount, BaseDays, Bonuses, BasePeriod, BaseHolidays,
	OnCompany}
from FinalPayments as Compensations
	//
	// Employees
	//
	join Catalog.Employees as Employees
	on Employees.Ref = Compensations.Employee
where not &amp;TaxesOnly
order by Employees.Description, Employees.Code, Compensations.DateStart, Priority, Level, Compensation
</query>
		<autoFillFields>false</autoFillFields>
		<useQueryGroupIfPossible>false</useQueryGroupIfPossible>
	</dataSet>
	<parameter>
		<name>DateStart</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Start Date </v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:type="xs:dateTime">0001-01-01T00:00:00</value>
		<useRestriction>true</useRestriction>
		<expression>&amp;Period.StartDate</expression>
		<availableAsField>false</availableAsField>
	</parameter>
	<parameter>
		<name>DateEnd</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Date end</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:type="xs:dateTime">0001-01-01T00:00:00</value>
		<useRestriction>true</useRestriction>
		<expression>&amp;Period.EndDate</expression>
		<availableAsField>false</availableAsField>
	</parameter>
	<parameter>
		<name>Period</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Period</v8:content>
			</v8:item>
			<v8:item>
				<v8:lang>ro</v8:lang>
				<v8:content>Perioad</v8:content>
			</v8:item>
			<v8:item>
				<v8:lang>ru</v8:lang>
				<v8:content></v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>v8:StandardPeriod</v8:Type>
		</valueType>
		<value xsi:type="v8:StandardPeriod">
			<v8:variant xsi:type="v8:StandardPeriodVariant">Custom</v8:variant>
			<v8:startDate>0001-01-01T00:00:00</v8:startDate>
			<v8:endDate>0001-01-01T00:00:00</v8:endDate>
		</value>
		<useRestriction>false</useRestriction>
		<denyIncompleteValues>true</denyIncompleteValues>
		<use>Always</use>
	</parameter>
	<parameter>
		<name>Ref</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Ref</v8:content>
			</v8:item>
			<v8:item>
				<v8:lang>ro</v8:lang>
				<v8:content>Ref</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type xmlns:d4p1="http://v8.1c.ru/8.1/data/enterprise/current-config">d4p1:DocumentRef.Payroll</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
	</parameter>
	<parameter>
		<name>StartMonth</name>
		<title xsi:type="xs:string">Start month</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:type="xs:dateTime">0001-01-01T00:00:00</value>
		<useRestriction>true</useRestriction>
		<expression>beginofperiod ( &amp;Period.StartDate, "month" )</expression>
		<availableAsField>false</availableAsField>
		<use>Always</use>
	</parameter>
	<parameter>
		<name>EndMonth</name>
		<title xsi:type="xs:string">End month</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:type="xs:dateTime">0001-01-01T00:00:00</value>
		<useRestriction>true</useRestriction>
		<expression>endofperiod ( &amp;Period.EndDate, "month" )</expression>
		<availableAsField>false</availableAsField>
		<use>Always</use>
	</parameter>
	<parameter>
		<name>CalculatingPayroll</name>
		<title xsi:type="xs:string">Calculating payroll</title>
		<valueType>
			<v8:Type xmlns:d4p1="http://v8.1c.ru/8.1/data/enterprise/current-config">d4p1:DocumentRef.Payroll</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
		<availableAsField>false</availableAsField>
	</parameter>
	<parameter>
		<name>CalculatingTaxesPayroll</name>
		<title xsi:type="xs:string">Calculating taxes payroll</title>
		<valueType>
			<v8:Type xmlns:d4p1="http://v8.1c.ru/8.1/data/enterprise/current-config">d4p1:DocumentRef.Payroll</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
		<availableAsField>false</availableAsField>
	</parameter>
	<parameter>
		<name>CalculationVariant</name>
		<title xsi:type="xs:string">Calculation variant</title>
		<valueType>
			<v8:Type>xs:decimal</v8:Type>
			<v8:NumberQualifiers>
				<v8:Digits>0</v8:Digits>
				<v8:FractionDigits>0</v8:FractionDigits>
				<v8:AllowedSign>Any</v8:AllowedSign>
			</v8:NumberQualifiers>
		</valueType>
		<value xsi:type="xs:decimal">0</value>
		<useRestriction>true</useRestriction>
		<availableAsField>false</availableAsField>
		<use>Always</use>
	</parameter>
	<parameter>
		<name>Calculating</name>
		<title xsi:type="xs:string">Calculating</title>
		<valueType>
			<v8:Type>xs:boolean</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
		<expression>case when &amp;CalculationVariant = 2 then true else false end</expression>
		<availableAsField>false</availableAsField>
		<use>Always</use>
	</parameter>
	<parameter>
		<name>TaxesOnly</name>
		<title xsi:type="xs:string">Taxes only</title>
		<valueType>
			<v8:Type>xs:boolean</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
		<expression>case when &amp;CalculationVariant = 3 then true else false end</expression>
		<availableAsField>false</availableAsField>
		<use>Always</use>
	</parameter>
	<parameter>
		<name>CalculatingDocument</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Calculating document</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type xmlns:d4p1="http://v8.1c.ru/8.1/data/enterprise/current-config">d4p1:DocumentRef.PayEmployees</v8:Type>
			<v8:Type>xs:boolean</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>false</useRestriction>
	</parameter>
	<parameter>
		<name>BeginOfPeriod</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Begin of period</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>false</useRestriction>
	</parameter>
	<parameter>
		<name>Percent</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Percent</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:decimal</v8:Type>
			<v8:NumberQualifiers>
				<v8:Digits>0</v8:Digits>
				<v8:FractionDigits>0</v8:FractionDigits>
				<v8:AllowedSign>Any</v8:AllowedSign>
			</v8:NumberQualifiers>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
	</parameter>
	<parameter>
		<name>CalculatingTaxesDocument</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Calculating taxes document</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type xmlns:d4p1="http://v8.1c.ru/8.1/data/enterprise/current-config">d4p1:DocumentRef.PayEmployees</v8:Type>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
	</parameter>
	<parameter>
		<name>EndOfPeriod</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>End of period</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>false</useRestriction>
	</parameter>
	<parameter>
		<name>YearStart</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Year start</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
	</parameter>
	<parameter>
		<name>BalancesDate</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Balances date</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:nil="true"/>
		<useRestriction>true</useRestriction>
	</parameter>
	<parameter>
		<name>Account</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Account</v8:content>
			</v8:item>
		</title>
		<useRestriction>true</useRestriction>
		<valueListAllowed>true</valueListAllowed>
	</parameter>
	<parameter>
		<name>PaymentDate</name>
		<title xsi:type="xs:string">Payment date</title>
		<valueType>
			<v8:Type>xs:dateTime</v8:Type>
			<v8:DateQualifiers>
				<v8:DateFractions>DateTime</v8:DateFractions>
			</v8:DateQualifiers>
		</valueType>
		<value xsi:type="xs:dateTime">0001-01-01T00:00:00</value>
		<useRestriction>true</useRestriction>
		<availableAsField>false</availableAsField>
	</parameter>
	<parameter>
		<name>Additions</name>
		<title xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Additions</v8:content>
			</v8:item>
		</title>
		<valueType>
			<v8:Type>xs:string</v8:Type>
			<v8:StringQualifiers>
				<v8:Length>0</v8:Length>
				<v8:AllowedLength>Variable</v8:AllowedLength>
			</v8:StringQualifiers>
		</valueType>
		<value xsi:type="xs:string"/>
		<useRestriction>true</useRestriction>
		<availableAsField>false</availableAsField>
	</parameter>
	<settingsVariant>
		<dcsset:name>#Fill</dcsset:name>
		<dcsset:presentation xsi:type="v8:LocalStringType">
			<v8:item>
				<v8:lang>en</v8:lang>
				<v8:content>Payroll</v8:content>
			</v8:item>
			<v8:item>
				<v8:lang>ru</v8:lang>
				<v8:content> </v8:content>
			</v8:item>
			<v8:item>
				<v8:lang>ro</v8:lang>
				<v8:content>Calcule salariale</v8:content>
			</v8:item>
		</dcsset:presentation>
		<dcsset:settings xmlns:style="http://v8.1c.ru/8.1/data/ui/style" xmlns:sys="http://v8.1c.ru/8.1/data/ui/fonts/system" xmlns:web="http://v8.1c.ru/8.1/data/ui/colors/web" xmlns:win="http://v8.1c.ru/8.1/data/ui/colors/windows">
			<dcsset:selection>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Account</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>AccountingResult</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Compensation</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Currency</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>DateEnd</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>DateStart</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Days</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Department</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Employee</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Individual</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>ExchangeFactor</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>ExchangeRate</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Expenses</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>HourlyRate</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Hours</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Level</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Position</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Priority</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Rate</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Result</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Schedule</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>ScheduledDays</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>ScheduledHours</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Edit</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>BaseAmount</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>BaseDays</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>BaseHolidays</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>BasePeriod</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Bonuses</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>DailyRate</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Reference</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>Key</dcsset:field>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:SelectedItemField">
					<dcsset:field>OnCompany</dcsset:field>
				</dcsset:item>
			</dcsset:selection>
			<dcsset:filter>
				<dcsset:item xsi:type="dcsset:FilterItemComparison">
					<dcsset:use>false</dcsset:use>
					<dcsset:left xsi:type="dcscor:Field">Employee</dcsset:left>
					<dcsset:comparisonType>Equal</dcsset:comparisonType>
					<dcsset:userSettingID>5c381009-bce8-49d8-adfc-fd38b8d60507</dcsset:userSettingID>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:FilterItemComparison">
					<dcsset:use>false</dcsset:use>
					<dcsset:left xsi:type="dcscor:Field">Department</dcsset:left>
					<dcsset:comparisonType>Equal</dcsset:comparisonType>
					<dcsset:userSettingID>a79c62ca-e10a-486b-a641-93f3ebc0237b</dcsset:userSettingID>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:FilterItemComparison">
					<dcsset:use>false</dcsset:use>
					<dcsset:left xsi:type="dcscor:Field">Position</dcsset:left>
					<dcsset:comparisonType>Equal</dcsset:comparisonType>
					<dcsset:viewMode>Normal</dcsset:viewMode>
					<dcsset:userSettingID>47ccdb38-fc42-48cc-8571-a41e47909a8c</dcsset:userSettingID>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:FilterItemComparison">
					<dcsset:use>false</dcsset:use>
					<dcsset:left xsi:type="dcscor:Field">Schedule</dcsset:left>
					<dcsset:comparisonType>Equal</dcsset:comparisonType>
					<dcsset:viewMode>Normal</dcsset:viewMode>
					<dcsset:userSettingID>1962b207-fd39-46c1-bbcf-a27f84a4e4c5</dcsset:userSettingID>
				</dcsset:item>
			</dcsset:filter>
			<dcsset:dataParameters>
				<dcscor:item xsi:type="dcsset:SettingsParameterValue">
					<dcscor:use>false</dcscor:use>
					<dcscor:parameter>Period</dcscor:parameter>
					<dcscor:value xsi:type="v8:StandardPeriod">
						<v8:variant xsi:type="v8:StandardPeriodVariant">Custom</v8:variant>
						<v8:startDate>0001-01-01T00:00:00</v8:startDate>
						<v8:endDate>0001-01-01T00:00:00</v8:endDate>
					</dcscor:value>
					<dcsset:viewMode>Normal</dcsset:viewMode>
					<dcsset:userSettingID>6e7202f8-c606-4e87-9989-582b4f846e6e</dcsset:userSettingID>
				</dcscor:item>
				<dcscor:item xsi:type="dcsset:SettingsParameterValue">
					<dcscor:use>false</dcscor:use>
					<dcscor:parameter>PaymentDate</dcscor:parameter>
					<dcscor:value xsi:type="xs:dateTime">0001-01-01T00:00:00</dcscor:value>
					<dcsset:viewMode>Normal</dcsset:viewMode>
				</dcscor:item>
			</dcsset:dataParameters>
			<dcsset:order>
				<dcsset:item xsi:type="dcsset:OrderItemField">
					<dcsset:field>Employee</dcsset:field>
					<dcsset:orderType>Asc</dcsset:orderType>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:OrderItemField">
					<dcsset:field>Employee.Code</dcsset:field>
					<dcsset:orderType>Asc</dcsset:orderType>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:OrderItemField">
					<dcsset:field>DateStart</dcsset:field>
					<dcsset:orderType>Asc</dcsset:orderType>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:OrderItemField">
					<dcsset:field>Priority</dcsset:field>
					<dcsset:orderType>Asc</dcsset:orderType>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:OrderItemField">
					<dcsset:field>Level</dcsset:field>
					<dcsset:orderType>Asc</dcsset:orderType>
				</dcsset:item>
				<dcsset:item xsi:type="dcsset:OrderItemField">
					<dcsset:field>Compensation</dcsset:field>
					<dcsset:orderType>Asc</dcsset:orderType>
				</dcsset:item>
			</dcsset:order>
			<dcsset:outputParameters>
				<dcscor:item xsi:type="dcsset:SettingsParameterValue">
					<dcscor:parameter>AppearanceTemplate</dcscor:parameter>
					<dcscor:value xsi:type="xs:string">Reports</dcscor:value>
				</dcscor:item>
				<dcscor:item xsi:type="dcsset:SettingsParameterValue">
					<dcscor:parameter>Title</dcscor:parameter>
					<dcscor:value xsi:type="v8:LocalStringType">
						<v8:item>
							<v8:lang>en</v8:lang>
							<v8:content>Payroll Accounting</v8:content>
						</v8:item>
						<v8:item>
							<v8:lang>ru</v8:lang>
							<v8:content> </v8:content>
						</v8:item>
						<v8:item>
							<v8:lang>ro</v8:lang>
							<v8:content>Calcule salariale</v8:content>
						</v8:item>
					</dcscor:value>
				</dcscor:item>
			</dcsset:outputParameters>
			<dcsset:item xsi:type="dcsset:StructureItemGroup">
				<dcsset:order>
					<dcsset:item xsi:type="dcsset:OrderItemAuto"/>
				</dcsset:order>
				<dcsset:selection>
					<dcsset:item xsi:type="dcsset:SelectedItemAuto"/>
				</dcsset:selection>
			</dcsset:item>
		</dcsset:settings>
	</settingsVariant>
</DataCompositionSchema>